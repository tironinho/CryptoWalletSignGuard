{
  "version": 3,
  "sources": ["../src/lists/cryptoTrustedDomainsSeed.ts", "../src/shared/types.ts", "../src/runtimeSafe.ts", "../src/shared/optionalOrigins.ts", "../src/permissions.ts", "../src/onboarding.ts"],
  "sourcesContent": ["/**\n * Seed de dom\u00EDnios confi\u00E1veis crypto-only (sem twitter/discord/social).\n * Usado em allowlist/trustedDomains e listSeeds.\n */\n\nexport const CRYPTO_TRUSTED_DOMAINS_SEED: string[] = [\n  // Explorers\n  \"etherscan.io\",\n  \"etherscan.com\",\n  \"arbiscan.io\",\n  \"polygonscan.com\",\n  \"bscscan.com\",\n  \"basescan.org\",\n  \"snowtrace.io\",\n  \"optimistic.etherscan.io\",\n  // NFTs\n  \"opensea.io\",\n  \"blur.io\",\n  \"looksrare.org\",\n  \"x2y2.io\",\n  \"rarible.com\",\n  \"magiceden.io\",\n  // DEX/DeFi\n  \"uniswap.org\",\n  \"app.uniswap.org\",\n  \"1inch.io\",\n  \"app.1inch.io\",\n  \"aave.com\",\n  \"app.aave.com\",\n  \"curve.fi\",\n  \"app.curve.fi\",\n  \"balancer.fi\",\n  \"app.balancer.fi\",\n  \"sushiswap.fi\",\n  \"matcha.xyz\",\n  \"paraswap.io\",\n  \"cowswap.exchange\",\n  // Bridges/L2\n  \"bridge.arbitrum.io\",\n  \"optimism.io\",\n  \"base.org\",\n  \"arbitrum.io\",\n  \"polygon.technology\",\n  \"hop.exchange\",\n  \"stargate.finance\",\n  \"across.to\",\n  \"portalbridge.com\",\n  \"zksync.io\",\n  // Infra / Wallets\n  \"chain.link\",\n  \"lido.fi\",\n  \"stake.lido.fi\",\n  \"ens.domains\",\n  \"app.ens.domains\",\n  \"metamask.io\",\n  \"metamask.com\",\n  \"rabby.io\",\n  \"walletconnect.com\",\n  \"walletconnect.org\",\n  \"safe.global\",\n  \"revoke.cash\",\n  \"app.revoke.cash\",\n];\n", "export type WalletKind = \"EVM_INJECTED\" | \"SOLANA_INJECTED\" | \"UNKNOWN\";\nexport type WalletName =\n  | \"MetaMask\"\n  | \"Coinbase Wallet\"\n  | \"Trust\"\n  | \"Rabby\"\n  | \"OKX Wallet\"\n  | \"Binance Web3\"\n  | \"Rainbow\"\n  | \"Phantom\"\n  | \"Phantom EVM\"\n  | \"SafePal\"\n  | \"Bitget Wallet\"\n  | \"Brave Wallet\"\n  | \"Taho\"\n  | \"Ledger\"\n  | \"Frame\"\n  | \"MathWallet\"\n  | \"Solflare\"\n  | \"Backpack\"\n  | \"Injected\"\n  | \"EVM Wallet\"\n  | \"Unknown\";\n\nexport type WalletMeta = { id: string; name: string; iconHint?: string };\n\nexport type WalletBrand =\n  | \"MetaMask\"\n  | \"Coinbase Wallet\"\n  | \"Rabby\"\n  | \"Trust Wallet\"\n  | \"Brave Wallet\"\n  | \"OKX Wallet\"\n  | \"Binance Web3\"\n  | \"Bitget Wallet\"\n  | \"Phantom EVM\"\n  | \"EVM Wallet\";\n\nexport type WalletInfo = {\n  kind: WalletKind;\n  name: WalletName;\n  flags?: Record<string, boolean>;\n  walletBrand?: WalletBrand;\n  /** Display name for overlay (e.g. \"MetaMask\", \"EVM Wallet\") */\n  walletName?: string;\n};\n\nexport type EthRequest = {\n  method: string;\n  params?: any[];\n  // optional extra debugging/shape info from legacy provider entrypoints\n  rawShape?: string;\n  raw?: any;\n};\n\nexport type PendingRequestPayload = {\n  id: string;\n  url: string;\n  origin: string;\n  wallet?: WalletInfo | WalletMeta;\n  request: { method: string; params?: any[] };\n  providerTag?: string;\n  providerKey?: string;\n  providerSource?: \"window.ethereum\" | \"ethereum.providers[i]\" | \"eip6963\";\n};\n\n/** P0 UI Gate: meta sent with SG_DECISION to ensure wallet is only forwarded after user confirmed in overlay. */\nexport type DecisionMeta = {\n  uiConfirmed?: boolean;\n  uiGate?: boolean;\n  reasonKeys?: string[];\n  method?: string;\n};\n\nexport type FeeEstimateWire = {\n  ok: boolean;\n  gasLimitHex?: string;\n  feeLikelyWeiHex?: string;\n  feeMaxWeiHex?: string;\n  feeEstimated?: boolean;\n  feeReasonKey?: string;\n  error?: string;\n};\n\nexport type TxContextKind = \"SWITCH_NETWORK\" | \"NFT_PURCHASE\" | \"TOKEN_SWAP\" | \"VALUE_TRANSFER\" | \"CONTRACT_CALL\" | \"APPROVAL\";\n\nexport type AnalyzeRequest = {\n  requestId: string;\n  url: string;\n  origin: string;\n  request: EthRequest;\n  tabId?: number;\n  wallet?: WalletInfo;\n  providerHint?: { kind: ProviderKind; name?: string };\n  txCostPreview?: TxCostPreview;\n  feeEstimate?: FeeEstimateWire;\n  meta?: {\n    chainId?: string;\n    chainIdHex?: string;\n    chainIdRequested?: string;\n    txContext?: { kind: TxContextKind };\n    pageRisk?: { score: \"LOW\" | \"MEDIUM\" | \"HIGH\"; reasons: string[] };\n    preflight?: {\n      tx?: any;\n      valueWei?: string; // decimal\n      valueEth?: string; // decimal\n      gasEstimate?: string; // hex\n      gasPrice?: string; // hex\n      feeWeiEstimated?: string; // decimal\n      feeEthEstimated?: string; // decimal\n      totalEthEstimated?: string; // decimal\n    }\n  };\n};\n\nexport type SecurityMode = \"STRICT\" | \"BALANCED\" | \"RELAXED\" | \"OFF\";\nexport type ProviderKind = \"EIP6963\" | \"METAMASK\" | \"RABBY\" | \"COINBASE\" | \"PHANTOM\" | \"UNKNOWN\";\n\nexport type ChainIdHex = string; // ex \"0x1\"\nexport type Address = string; // \"0x...\" lowercase\n\n/** Domain list decision for risk/UX (whitelist never auto-allows tx). */\nexport type DomainDecision = \"TRUSTED\" | \"BLOCKED\" | \"UNKNOWN\";\n\n/** Cache key for scam token: chainId:tokenAddressLower */\nexport type ScamTokenKey = `${string}:${string}`;\n\nexport type ListSourceName = \"metamask\" | \"scamsniffer\" | \"cryptoscamdb\" | \"dappradar\" | \"mew\" | \"seed\" | \"user\";\n\nexport type ListsCacheV1 = {\n  version: 1;\n  updatedAt: number;\n  sources: Record<ListSourceName, { updatedAt?: number; etag?: string; ok?: boolean; error?: string }>;\n  trustedDomains: string[];\n  blockedDomains: string[];\n  blockedAddresses: string[];\n  scamTokens: Array<{ chainId: string; address: string; symbol?: string; name?: string; source?: ListSourceName }>;\n  userTrustedDomains: string[];\n  userBlockedDomains: string[];\n  userBlockedAddresses: string[];\n  userScamTokens: Array<{ chainId: string; address: string; symbol?: string; name?: string }>;\n  userTrustedTokens: Array<{ chainId: string; address: string }>;\n};\n\nexport type ThreatIntelAddress = {\n  address: Address;\n  chainId?: ChainIdHex;\n  label: string;\n  category: \"DRAINER\" | \"SCAM_TOKEN\" | \"SCAM_ROUTER\" | \"MALICIOUS_SPENDER\" | \"UNKNOWN\";\n  sourceId: string;\n  confidence: 1 | 2 | 3;\n  updatedAt: number;\n};\n\nexport type ThreatIntelBundle = {\n  updatedAt: number;\n  sources: Array<{ id: string; url?: string; ok: boolean; fetchedAt: number; error?: string }>;\n  trustedDomainsSeed: string[];\n  blockedDomains: string[];\n  blockedAddresses: ThreatIntelAddress[];\n};\n\nexport type AssetInfo = {\n  chainId: ChainIdHex;\n  address: Address;\n  kind: \"ERC20\" | \"ERC721\" | \"ERC1155\" | \"UNKNOWN\";\n  name?: string;\n  symbol?: string;\n  decimals?: number;\n  fetchedAt: number;\n};\n\nexport type DecodedAction = (\n  | { kind: \"APPROVE_ERC20\"; token: Address; spender: Address; amountType: \"LIMITED\" | \"UNLIMITED\"; amountRaw?: string }\n  | { kind: \"INCREASE_ALLOWANCE\"; token: Address; spender: Address; amountType: \"LIMITED\" | \"UNLIMITED\"; amountRaw?: string }\n  | { kind: \"DECREASE_ALLOWANCE\"; token: Address; spender: Address; amountRaw?: string }\n  | { kind: \"TRANSFER_ERC20\"; token: Address; to: Address; amountRaw?: string }\n  | { kind: \"TRANSFERFROM_ERC20\"; token: Address; from: Address; to: Address; amountRaw?: string }\n  | { kind: \"SET_APPROVAL_FOR_ALL\"; token: Address; operator: Address; approved: boolean }\n  | { kind: \"TRANSFER_NFT\"; token: Address; to: Address; from?: Address; tokenIdRaw?: string; amountRaw?: string; standard: \"ERC721\" | \"ERC1155\" | \"UNKNOWN\"; batch?: boolean }\n  | { kind: \"PERMIT_EIP2612\"; token: Address; spender: Address; valueType: \"LIMITED\" | \"UNLIMITED\"; valueRaw?: string; deadlineRaw?: string }\n  | { kind: \"PERMIT2_ALLOWANCE\"; token: Address; spender: Address; amountType: \"LIMITED\" | \"UNLIMITED\"; amountRaw?: string; deadlineRaw?: string }\n  | { kind: \"PERMIT2_TRANSFER\"; token: Address; to: Address; amountType: \"LIMITED\" | \"UNLIMITED\"; amountRaw?: string }\n  | { kind: \"UNKNOWN\"; selector?: string }\n  | { kind: \"MULTICALL\"; selector: string; raw?: string }\n  )\n  & { permit2?: boolean; marketplaceHint?: string };\n\nexport type RiskLevel = \"LOW\" | \"WARN\" | \"HIGH\";\n\nexport type Recommend = \"ALLOW\" | \"WARN\" | \"HIGH\" | \"BLOCK\";\n\nexport type CheckKey =\n  | \"DOMAIN_INTEL\"\n  | \"LOOKALIKE\"\n  | \"TX_DECODE\"\n  | \"FEE_ESTIMATE\"\n  | \"ADDRESS_INTEL\"\n  | \"ASSET_ENRICH\"\n  | \"CLOUD_INTEL\";\n\nexport type CheckStatus = \"PASS\" | \"WARN\" | \"FAIL\" | \"SKIP\";\n\nexport interface CheckResult {\n  key: CheckKey;\n  status: CheckStatus;\n  noteKey?: string;\n}\n\nexport type DecodedKind =\n  | \"APPROVE\"\n  | \"SET_APPROVAL_FOR_ALL\"\n  | \"TYPED_DATA\"\n  | \"TX\"\n  | \"CONNECT\"\n  | \"SIGN\";\n\nexport type Decoded = {\n  kind: DecodedKind;\n  tokenOrCollection?: string;\n  spenderOrOperator?: string;\n  amountHuman?: string;\n  raw?: any;\n};\n\nexport type TrustVerdict = \"LIKELY_OFFICIAL\" | \"UNKNOWN\" | \"SUSPICIOUS\";\n\nexport type TrustAnalysis = {\n  verdict: TrustVerdict;\n  trustScore: number; // 0-100\n  reasons: string[];\n  matchedAllowlistDomain?: string;\n};\n\nexport type HumanExplanation = {\n  methodTitle: string;\n  methodShort: string;\n  methodWhy: string;\n  whatItDoes?: string[];\n  siteSees?: string[];\n  notHappen?: string[];\n  whyAsked?: string[];\n  risks: string[];\n  safeNotes: string[];\n  safe?: string[];\n  nextSteps: string[];\n  recommendation: string;\n  links?: Array<{ text: string; href: string }>;\n};\n\nexport type ThreatIntel = {\n  updatedAt: number;\n  sources: Array<{ id: string; url: string; ok: boolean; fetchedAt: number; error?: string }>;\n  trustedDomains: string[];\n  blockedDomains: string[];\n};\n\nexport type TxCostPreview = {\n  valueWei: string;                 // decimal string\n  feeEstimated: boolean;\n  gasLimitWei?: string;             // decimal string (gasLimit as bigint)\n  feeLikelyWei?: string;            // decimal string\n  feeMaxWei?: string;               // decimal string\n  totalLikelyWei?: string;          // decimal string\n  totalMaxWei?: string;             // decimal string\n  feeReasonKey?: string;            // i18n key when feeEstimated=false\n  /** USD per 1 unit of native token (for overlay). */\n  usdPerNative?: number;\n};\n\nexport type TxSummary = {\n  to?: string;\n  valueWei?: string;        // decimal\n  valueEth?: string;        // formatted\n  selector?: string;        // 0x + 8 hex\n  gasLimit?: string;        // decimal\n  maxFeePerGasWei?: string; // decimal\n  maxPriorityFeePerGasWei?: string; // decimal (EIP-1559 tip)\n  maxGasFeeEth?: string;    // ETH\n  maxTotalEth?: string;     // ETH (value + maxGasFee)\n  feeKnown?: boolean;\n  contractNameHint?: string;\n  dataLen?: number;         // raw data length\n};\n\nexport type Intent = \"NFT_PURCHASE\" | \"SWAP\" | \"APPROVAL\" | \"SEND\" | \"ETH_TRANSFER\" | \"TOKEN_TRANSFER\" | \"NFT_TRANSFER\" | \"CONTRACT_INTERACTION\" | \"CONNECT\" | \"SIGN\" | \"SIGNATURE\" | \"TYPED_DATA\" | \"CHAIN\" | \"SWITCH_CHAIN\" | \"ADD_CHAIN\" | \"WATCH_ASSET\" | \"SOLANA\" | \"UNKNOWN\";\n\nexport type TxExtras =\n  | {\n      approvalType: \"ERC20_APPROVE\";\n      tokenContract?: string;\n      spender?: string;\n      unlimited?: boolean;\n    }\n  | {\n      approvalType: \"NFT_SET_APPROVAL_FOR_ALL\";\n      tokenContract?: string;\n      operator?: string;\n      unlimited?: boolean;\n    }\n  | {\n      approvalType?: \"NFT_TRANSFER\";\n      tokenContract?: string;\n      toAddress?: string;\n    };\n\n/** P1: Transaction summary v1 for overlay (give/get, approvals, nfts, flags). */\nexport type TxSummaryV1 = {\n  title: string;\n  subtitle?: string;\n  give?: Array<{ amount?: string; symbol?: string; kind: \"NATIVE\" | \"ERC20\" | \"NFT\" | \"UNKNOWN\"; tokenAddress?: string; tokenId?: string; to?: string }>;\n  get?: Array<{ amount?: string; symbol?: string; kind: \"NATIVE\" | \"ERC20\" | \"NFT\" | \"UNKNOWN\"; tokenAddress?: string; tokenId?: string; to?: string }>;\n  approvals?: Array<{ kind: \"ERC20\" | \"ERC721_ALL\" | \"ERC1155_ALL\" | \"PERMIT\" | \"PERMIT2\"; tokenAddress?: string; tokenSymbol?: string; spender?: string; amount?: string; unlimited?: boolean; deadline?: string }>;\n  nfts?: Array<{ collection?: string; tokenAddress?: string; tokenId?: string; amount?: string; to?: string; marketplace?: string }>;\n  flags?: string[]; // reasonKeys\n};\n\nexport type Analysis = {\n  level: RiskLevel;\n  score: number; // 0-100\n  title: string;\n  reasons: string[];\n  decoded?: Decoded;\n  decodedAction?: DecodedAction;\n  recommend: Recommend;\n  trust?: TrustAnalysis;\n  human?: HumanExplanation;\n  suggestedTrustedDomains?: string[];\n  tx?: TxSummary;\n  txCostPreview?: TxCostPreview;\n  txExtras?: TxExtras;\n  intent?: Intent;\n  txContext?: { kind: TxContextKind };\n  chainTarget?: { chainIdHex: string; chainName?: string };\n  addChainInfo?: { chainId: string; chainName?: string; rpcUrls?: string[]; nativeCurrencySymbol?: string };\n  watchAssetInfo?: { type: string; address?: string; symbol?: string; decimals?: number; image?: string };\n  wallet?: WalletInfo;\n  safeDomain?: boolean;\n  isPhishing?: boolean;\n  domainRisk?: { scoreDelta: number; reasons: string[] };\n  addressRisk?: { flagged: boolean; reasons: string[]; matches?: string[] };\n  method?: string;\n  asset?: AssetInfo;\n  flaggedAddress?: ThreatIntelAddress;\n  provider?: { kind: ProviderKind; name?: string };\n  feeGtValue?: boolean;\n  /** Checks performed (security coverage). */\n  checks?: CheckResult[];\n  /** Coverage summary: performed/total, limited when some checks unavailable. */\n  coverage?: { performed: number; total: number; limited: boolean };\n  /** i18n key for main verdict label (e.g. verdict_ok, verdict_warn, verdict_high, verdict_block). */\n  verdictLabelKey?: string;\n  /** When tx.to is a contract (eth_getCode !== \"0x\"). */\n  toIsContract?: boolean;\n  /** Verification level: FULL = intel fresh, LOCAL = cached, BASIC = no intel. */\n  verificationLevel?: \"FULL\" | \"LOCAL\" | \"BASIC\";\n  /** Timestamp of cached intel used (if any). */\n  verificationUpdatedAt?: number;\n  /** true when domain trusted/allowlisted + no flags + no suspicious addr. */\n  knownSafe?: boolean;\n  /** true when phishing/lookalike HIGH + blacklist. */\n  knownBad?: boolean;\n  /** Spender matched denylistSpenders \u2192 BLOCK. */\n  matchedDenySpender?: boolean;\n  /** Spender matched allowlistSpenders \u2192 reduce score. */\n  matchedAllowSpender?: boolean;\n  /** Domain-related signals, e.g. METAMASK_SEED, BLACKLIST_HIT, LOOKALIKE, PUNYCODE, SEED_MATCH, SUSPICIOUS_TLD. */\n  domainSignals?: string[];\n  /** Intel source ids used, e.g. metamask, cryptoscamdb, scamsniffer, local_seed. */\n  intelSources?: string[];\n  /** List manager domain decision: TRUSTED / BLOCKED / UNKNOWN (for site reputation badge). */\n  domainListDecision?: DomainDecision;\n  /** Extras from typed-data (e.g. Permit: spender, value, deadline). */\n  typedDataExtras?: { spender?: string; value?: string; deadline?: string };\n  /** Structured decode for Permit2 / Seaport / Blur typed data (human overlay). */\n  typedDataDecoded?: {\n    permit2?: { spender: string; tokens: string[]; amounts: string[]; unlimited?: boolean; sigDeadline?: string };\n    seaport?: { offerSummary: string; considerationSummary: string; primaryType?: string };\n    isBlur?: boolean;\n  };\n  /** true when any address (to/spender/operator/tokenContract) matched address intel labels. */\n  addressIntelHit?: boolean;\n  /** Labels per role when address intel hit (human-readable label strings). */\n  addressIntel?: {\n    to?: string[];\n    spender?: string[];\n    operator?: string[];\n    tokenContract?: string[];\n  };\n  /** Result of Tenderly simulation (if run). SKIPPED when API failed (fallback). */\n  simulationOutcome?: {\n    status: \"SUCCESS\" | \"REVERT\" | \"RISK\" | \"SKIPPED\";\n    outgoingAssets: Array<{ symbol: string; amount: string; logo?: string }>;\n    incomingAssets: Array<{ symbol: string; amount: string; logo?: string }>;\n    approvals?: Array<{ token: string; spender: string; approved: boolean; unlimited?: boolean; approvalForAll?: boolean }>;\n    gasUsed: string;\n    fallback?: boolean;\n    gasCostWei?: string;\n    isHighGas?: boolean;\n    simulated?: boolean;\n    message?: string;\n  };\n  /** True when simulation predicted revert (show \"ESTA TRANSA\u00C7\u00C3O VAI FALHAR\"). */\n  simulationRevert?: boolean;\n  /** Token confidence: SCAM, TRUSTED, LOW (new/unverified), UNKNOWN. */\n  tokenConfidence?: \"SCAM\" | \"TRUSTED\" | \"LOW\" | \"UNKNOWN\";\n  /** First-seen timestamp for token (when LOW/UNKNOWN). */\n  tokenFirstSeenAt?: number;\n  /** True when honeypot detected (buy but cannot sell / transfer). */\n  isHoneypot?: boolean;\n  /** True when protection is temporarily paused (allow without showing overlay). */\n  protectionPaused?: boolean;\n  /** True when vault blocks this request (Cofre). */\n  vaultBlocked?: boolean;\n  /** Locked contract address when vaultBlocked. */\n  vaultLockedTo?: string;\n  /** ChainId for vault override (VAULT_UNLOCK). */\n  vaultChainIdHex?: string;\n  /** Standardized reason keys for consistency (maps to i18n). */\n  reasonKeys?: string[];\n  /** P1: Structured summary for overlay (title, give/get, approvals, nfts, flags). */\n  summary?: TxSummaryV1;\n  /** P1: Alias for summary (spec name summaryV1). */\n  summaryV1?: TxSummaryV1;\n}\n\nexport type SupportedWalletEntry = { name: string; kind: string };\n\n/** User-configurable settings (spec name: UserSettings). */\nexport type Settings = {\n  riskWarnings: boolean;\n  showConnectOverlay: boolean;\n  blockHighRisk: boolean;\n  requireTypedOverride?: boolean;\n  allowOverrideOnPhishing?: boolean;\n  debugMode?: boolean;\n  domainChecks: boolean;\n  allowlist: string[];\n  trustedDomains?: string[];\n  customBlockedDomains?: string[];\n  customTrustedDomains?: string[];\n  /** P0-C: User allow/deny by spender address (for approvals). */\n  allowlistSpenders?: string[];\n  denylistSpenders?: string[];\n  /** fail_open: allow when runtime unavailable; fail_closed: block on high risk. */\n  failMode?: \"fail_open\" | \"fail_closed\";\n  enableIntel?: boolean;\n  mode?: SecurityMode;\n  supportedWalletsInfo?: SupportedWalletEntry[];\n  strictBlockApprovalsUnlimited?: boolean;\n  strictBlockSetApprovalForAll?: boolean;\n  strictBlockPermitLike?: boolean;\n  assetEnrichmentEnabled?: boolean;\n  addressIntelEnabled?: boolean;\n  /** P0-E: Allow external checks (more protection; may send domain/address for validation). Default false. */\n  cloudIntelOptIn?: boolean;\n  /** Telemetry/analytics opt-in. Default false. Requires termsAccepted. Independent of cloudIntelOptIn. */\n  telemetryOptIn?: boolean;\n  /** @deprecated Use telemetryOptIn. Kept for migration. */\n  telemetryEnabled?: boolean;\n  showUsd?: boolean;\n  planTier?: \"FREE\" | \"PRO\";\n  licenseKey?: string;\n  /** Cofre SignGuard: contracts that must not be transacted without explicit unlock. */\n  vault?: {\n    enabled: boolean;\n    lockedContracts: string[];\n    /** Timestamp until which vault is temporarily unlocked (Date.now() + ms). */\n    unlockedUntil?: number;\n    /** Also block approvals/permits when spender is in lockedContracts. */\n    blockApprovals?: boolean;\n  };\n  /** Tenderly simulation (no hardcoded keys). */\n  simulation?: {\n    enabled: boolean;\n    tenderlyAccount: string;\n    tenderlyProject: string;\n    tenderlyKey: string;\n  };\n  /** Pause protection until this timestamp (Date.now() + ms). */\n  pausedUntil?: number;\n  /** Domains that bypass overlay when protection is active (e.g. trusted tools). */\n  whitelistedDomains?: string[];\n  /** Modo Fortaleza: bloqueia todas as aprova\u00E7\u00F5es de tokens exceto em sites confi\u00E1veis. */\n  fortressMode?: boolean;\n  /** Expandir se\u00E7\u00F5es detalhadas (accordions) do overlay por padr\u00E3o. */\n  defaultExpandDetails?: boolean;\n};\n\n/** Alias for Settings (spec: UserSettings). */\nexport type UserSettings = Settings;\n\n/** Stored in chrome.storage.local key \"sg_plan\". */\nexport type PlanState = {\n  tier: \"FREE\" | \"PRO\";\n  keyMasked?: string;\n  activatedAt?: number;\n  expiresAt?: number;\n};\n\nexport const SUPPORTED_WALLETS: SupportedWalletEntry[] = [\n  { name: \"MetaMask\", kind: \"EVM\" },\n  { name: \"Coinbase Wallet\", kind: \"EVM\" },\n  { name: \"Trust Wallet\", kind: \"EVM\" },\n  { name: \"OKX Wallet\", kind: \"EVM\" },\n  { name: \"Binance Web3\", kind: \"EVM\" },\n  { name: \"Rabby\", kind: \"EVM\" },\n  { name: \"Rainbow\", kind: \"EVM\" },\n  { name: \"Phantom\", kind: \"EVM/Solana\" },\n  { name: \"Brave Wallet\", kind: \"EVM\" },\n  { name: \"Bitget Wallet\", kind: \"EVM\" },\n  { name: \"MathWallet\", kind: \"EVM\" },\n  { name: \"Solflare\", kind: \"Solana\" },\n  { name: \"Backpack\", kind: \"Solana\" },\n];\n\nimport { CRYPTO_TRUSTED_DOMAINS_SEED } from \"../lists/cryptoTrustedDomainsSeed\";\n\nexport const DEFAULT_SETTINGS: Settings = {\n  riskWarnings: true,\n  showConnectOverlay: true,\n  blockHighRisk: true,\n  requireTypedOverride: true,\n  allowOverrideOnPhishing: false,\n  debugMode: false,\n  domainChecks: true,\n  mode: \"BALANCED\",\n  strictBlockApprovalsUnlimited: true,\n  strictBlockSetApprovalForAll: true,\n  strictBlockPermitLike: true,\n  assetEnrichmentEnabled: true,\n  addressIntelEnabled: true,\n  cloudIntelOptIn: false,\n  telemetryOptIn: false,\n  telemetryEnabled: false,\n  showUsd: false,\n  defaultExpandDetails: true,\n  planTier: \"FREE\",\n  licenseKey: \"\",\n  trustedDomains: CRYPTO_TRUSTED_DOMAINS_SEED.slice(0, 24),\n  supportedWalletsInfo: SUPPORTED_WALLETS,\n  allowlist: CRYPTO_TRUSTED_DOMAINS_SEED.slice(0, 24),\n  customBlockedDomains: [],\n  customTrustedDomains: [],\n  allowlistSpenders: [],\n  denylistSpenders: [],\n  failMode: \"fail_open\",\n  enableIntel: true,\n  vault: {\n    enabled: false,\n    lockedContracts: [],\n    unlockedUntil: 0,\n    blockApprovals: false,\n  },\n  simulation: {\n    enabled: false,\n    tenderlyAccount: \"\",\n    tenderlyProject: \"\",\n    tenderlyKey: \"\",\n  },\n  whitelistedDomains: [],\n  fortressMode: false,\n};\n\n", "/**\r\n * Centralized runtime/storage wrappers to avoid \"Cannot read properties of undefined\"\r\n * and \"Extension context invalidated\" errors. Use in content and options scripts only.\r\n * Uses Port (long-lived) to reduce runtime.lastError / SW sleeping issues.\r\n */\r\n\r\nlet _port: chrome.runtime.Port | null = null;\r\n\r\nfunction hasRuntime(c: any): boolean {\r\n  try {\r\n    return !!(c?.runtime?.id && typeof c.runtime.sendMessage === \"function\");\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Retorna o chrome \"certo\" (o da extens\u00E3o) quando existir.\r\n * Alguns sites definem window.chrome sem runtime.id, ent\u00E3o N\u00C3O podemos priorizar globalThis.chrome cegamente.\r\n */\r\nfunction getChromeApi(): any | null {\r\n  const localChrome = typeof chrome !== \"undefined\" ? (chrome as any) : null;\r\n  if (hasRuntime(localChrome)) return localChrome;\r\n  const globalChrome = typeof globalThis !== \"undefined\" ? (globalThis as any).chrome : null;\r\n  if (hasRuntime(globalChrome)) return globalChrome;\r\n  return null;\r\n}\r\n\r\n/** Safe check: avoid crash when context invalidated. Use chrome da extens\u00E3o (runtime.id presente). */\r\nexport function canUseRuntime(): boolean {\r\n  try {\r\n    return !!getChromeApi();\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\nexport function isRuntimeUsable(): boolean {\r\n  try {\r\n    return canUseRuntime();\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\nconst CONTEXT_INVALID_TERMS = [\r\n  \"extension context invalidated\",\r\n  \"context invalidated\",\r\n  \"message port closed\",\r\n  \"receiving end does not exist\",\r\n  \"runtime.lastError\",\r\n];\r\n\r\nfunction isContextInvalidError(e: unknown): boolean {\r\n  const msg = String((e as Error)?.message ?? e ?? \"\").toLowerCase();\r\n  return CONTEXT_INVALID_TERMS.some((t) => msg.includes(t));\r\n}\r\n\r\nfunction getPort(): chrome.runtime.Port | null {\r\n  try {\r\n    const c = getChromeApi();\r\n    if (!c?.runtime?.connect) return null;\r\n    if (_port) return _port;\r\n    _port = c.runtime.connect({ name: \"sg_port\" });\r\n    _port?.onDisconnect.addListener(() => {\r\n      _port = null;\r\n      _portListenerInit = false;\r\n    });\r\n    return _port;\r\n  } catch {\r\n    _port = null;\r\n    return null;\r\n  }\r\n}\r\n\r\nconst _portPending = new Map<string, (r: any) => void>();\r\nlet _portListenerInit = false;\r\n\r\nfunction initPortListener() {\r\n  const p = getPort();\r\n  if (!p || _portListenerInit) return;\r\n  _portListenerInit = true;\r\n  p.onMessage.addListener((resp: any) => {\r\n    const cb = resp?.requestId != null ? _portPending.get(String(resp.requestId)) : undefined;\r\n    if (cb) {\r\n      _portPending.delete(String(resp.requestId));\r\n      try { cb(resp); } catch {}\r\n    }\r\n  });\r\n}\r\n\r\n/** Port-based request (preferred over sendMessage to avoid runtime.lastError). Sends PING via sendMessage first if port not yet connected (wakes SW). */\r\nexport function portRequest<T = any>(msg: unknown, timeoutMs = 2500): Promise<T | null> {\r\n  return new Promise((resolve) => {\r\n    (async () => {\r\n      try {\r\n        if (!_port) {\r\n          try {\r\n            await new Promise<void>((r) => {\r\n              const c = getChromeApi();\r\n              if (!c?.runtime?.sendMessage) return r();\r\n              c.runtime.sendMessage({ type: \"PING\" }, () => {\r\n                void (c?.runtime as { lastError?: { message?: string } })?.lastError;\r\n                r();\r\n              });\r\n              setTimeout(() => r(), 600);\r\n            });\r\n          } catch {\r\n            // ignore\r\n          }\r\n        }\r\n        const p = getPort();\r\n        if (!p) {\r\n          resolve(null);\r\n          return;\r\n        }\r\n        initPortListener();\r\n        const requestId = typeof crypto?.randomUUID === \"function\" ? crypto.randomUUID() : `sg_${Date.now()}_${Math.random().toString(36).slice(2)}`;\r\n        const payload = { ...(msg as object), requestId };\r\n\r\n        const timer = setTimeout(() => {\r\n          if (_portPending.has(requestId)) {\r\n            _portPending.delete(requestId);\r\n            resolve(null);\r\n          }\r\n        }, timeoutMs);\r\n\r\n        _portPending.set(requestId, (resp: any) => {\r\n          clearTimeout(timer);\r\n          resolve(resp != null ? (resp as T) : null);\r\n        });\r\n\r\n        try {\r\n          p.postMessage(payload);\r\n        } catch (e) {\r\n          clearTimeout(timer);\r\n          _portPending.delete(requestId);\r\n          resolve(null);\r\n        }\r\n      } catch {\r\n        resolve(null);\r\n      }\r\n    })();\r\n  });\r\n}\r\n\r\nconst DEFAULT_SEND_MS = 4000;\r\nconst RETRY_SEND_MS = 2500;\r\nconst LOG_PREFIX = \"[SignGuard]\";\r\n\r\nexport type SafeSendMessageOptions = {\r\n  timeoutMs?: number;\r\n  preferPort?: boolean;\r\n};\r\n\r\nfunction sendMessageOneAttempt<T>(msg: unknown, timeoutMs: number): Promise<T | null> {\r\n  return new Promise((resolve) => {\r\n    let settled = false;\r\n    const once = (value: T | null) => {\r\n      if (settled) return;\r\n      settled = true;\r\n      resolve(value);\r\n    };\r\n\r\n    const c = getChromeApi();\r\n    const rt = (() => {\r\n      try {\r\n        return c?.runtime ?? null;\r\n      } catch {\r\n        return null;\r\n      }\r\n    })();\r\n    if (!rt || !rt.id || typeof rt.sendMessage !== \"function\") {\r\n      once(null);\r\n      return;\r\n    }\r\n\r\n    const timer = setTimeout(() => {\r\n      once(null);\r\n    }, timeoutMs);\r\n\r\n    try {\r\n      rt.sendMessage(msg, (resp: T) => {\r\n        if (settled) return;\r\n        clearTimeout(timer);\r\n        try {\r\n          const err = (c?.runtime as any)?.lastError;\r\n          if (err) {\r\n            once(null);\r\n            return;\r\n          }\r\n          once(resp ?? null);\r\n        } catch {\r\n          once(null);\r\n        }\r\n      });\r\n    } catch (e) {\r\n      clearTimeout(timer);\r\n      // Production: no console.warn; keep only console.error in critical catch blocks\r\n      once(null);\r\n    }\r\n  });\r\n}\r\n\r\nexport function safeSendMessage<T = any>(msg: unknown, options?: number | SafeSendMessageOptions): Promise<T | null> {\r\n  const timeoutMs = typeof options === \"number\" ? options : (options?.timeoutMs ?? DEFAULT_SEND_MS);\r\n  const preferPort = typeof options === \"object\" && options?.preferPort === true;\r\n\r\n  if (preferPort) {\r\n    return portRequest<T>(msg, timeoutMs).then((r) => {\r\n      if (r != null && (r as any)?.ok !== false) return r as T;\r\n      return sendMessageOneAttempt<T>(msg, timeoutMs).then((res) => {\r\n        if (res != null) return res;\r\n        return sendMessageOneAttempt<T>(msg, RETRY_SEND_MS);\r\n      });\r\n    });\r\n  }\r\n\r\n  return sendMessageOneAttempt<T>(msg, timeoutMs).then((r) => {\r\n    if (r != null) return r;\r\n    return sendMessageOneAttempt<T>(msg, RETRY_SEND_MS);\r\n  });\r\n}\r\n\r\nexport type StorageResult<T> = { ok: true; data: T } | { ok: false; error: string };\r\n\r\nexport async function safeStorageGet<T = any>(keys: unknown): Promise<StorageResult<T>> {\r\n  return new Promise((resolve) => {\r\n    try {\r\n      const c = getChromeApi();\r\n      if (!c?.storage?.sync) {\r\n        resolve({ ok: false, error: \"storage_unavailable\" });\r\n        return;\r\n      }\r\n      c.storage.sync.get(keys as any, (items: T) => {\r\n        try {\r\n          const err = c.runtime?.lastError;\r\n          if (err) {\r\n            resolve({ ok: false, error: err.message || String(err) });\r\n            return;\r\n          }\r\n          resolve({ ok: true, data: items });\r\n        } catch (e) {\r\n          resolve({ ok: false, error: (e as Error)?.message || String(e) });\r\n        }\r\n      });\r\n    } catch (e) {\r\n      resolve({ ok: false, error: (e as Error)?.message || String(e) });\r\n    }\r\n  });\r\n}\r\n\r\nexport async function safeStorageSet(obj: Record<string, unknown>): Promise<StorageResult<true>> {\r\n  return new Promise((resolve) => {\r\n    try {\r\n      const c = getChromeApi();\r\n      if (!c?.storage?.sync) {\r\n        resolve({ ok: false, error: \"storage_unavailable\" });\r\n        return;\r\n      }\r\n      c.storage.sync.set(obj, () => {\r\n        try {\r\n          const err = c.runtime?.lastError;\r\n          if (err) {\r\n            resolve({ ok: false, error: err.message || String(err) });\r\n            return;\r\n          }\r\n          resolve({ ok: true, data: true });\r\n        } catch (e) {\r\n          resolve({ ok: false, error: (e as Error)?.message || String(e) });\r\n        }\r\n      });\r\n    } catch (e) {\r\n      resolve({ ok: false, error: (e as Error)?.message || String(e) });\r\n    }\r\n  });\r\n}\r\n\r\nexport async function safeLocalGet<T = any>(key: string): Promise<T | null> {\r\n  return new Promise((resolve) => {\r\n    try {\r\n      const c = getChromeApi();\r\n      if (!c?.storage?.local) {\r\n        resolve(null);\r\n        return;\r\n      }\r\n      c.storage.local.get(key, (r: Record<string, T>) => {\r\n        try {\r\n          const err = c.runtime?.lastError;\r\n          if (err) {\r\n            resolve(null);\r\n            return;\r\n          }\r\n          resolve(((r as any)?.[key] as T) ?? null);\r\n        } catch {\r\n          resolve(null);\r\n        }\r\n      });\r\n    } catch {\r\n      resolve(null);\r\n    }\r\n  });\r\n}\r\n\r\nexport async function safeLocalSet(obj: Record<string, unknown>): Promise<boolean> {\r\n  return new Promise((resolve) => {\r\n    try {\r\n      const c = getChromeApi();\r\n      if (!c?.storage?.local) {\r\n        resolve(false);\r\n        return;\r\n      }\r\n      c.storage.local.set(obj, () => {\r\n        try {\r\n          const err = c.runtime?.lastError;\r\n          resolve(!err);\r\n        } catch {\r\n          resolve(false);\r\n        }\r\n      });\r\n    } catch {\r\n      resolve(false);\r\n    }\r\n  });\r\n}\r\n\r\n/** Safe getURL - returns empty string if runtime unusable */\r\nexport function safeGetURL(path: string): string {\r\n  try {\r\n    const c = getChromeApi();\r\n    if (!c?.runtime?.getURL) return \"\";\r\n    return c.runtime.getURL(path);\r\n  } catch {\r\n    return \"\";\r\n  }\r\n}\r\n", "/**\n * Single source of truth for optional host origins per feature.\n * No fetch to these domains without (a) feature ON in settings and (b) user-granted permissions.\n */\n\nexport type OptionalFeature = \"cloudIntel\" | \"pricing\" | \"simulation\" | \"telemetry\";\n\nexport const OPTIONAL_ORIGINS: Record<OptionalFeature, string[]> = {\n  cloudIntel: [\n    \"https://raw.githubusercontent.com/*\",\n    \"https://api.cryptoscamdb.org/*\",\n    \"https://gitlab.com/*\",\n    \"https://gateway.ipfs.io/*\",\n    \"https://api.llama.fi/*\",\n  ],\n  pricing: [\n    \"https://api.coingecko.com/*\",\n    \"https://api.dexscreener.com/*\",\n  ],\n  simulation: [\"https://api.tenderly.co/*\"],\n  telemetry: [\"https://cjnzidctntqzamhwmwkt.supabase.co/*\"],\n};\n\n/** Returns origins for a single feature. */\nexport function getOriginsForFeature(feature: OptionalFeature): string[] {\n  const list = OPTIONAL_ORIGINS[feature];\n  return list ? [...list] : [];\n}\n\n/** Returns origins for multiple features (deduplicated). */\nexport function getOriginsForFeatures(features: OptionalFeature[]): string[] {\n  const set = new Set<string>();\n  for (const f of features) {\n    const list = OPTIONAL_ORIGINS[f];\n    if (list) for (const o of list) set.add(o);\n  }\n  return [...set];\n}\n\n/** Union of all optional origins (deduplicated). */\nexport function getAllOptionalOrigins(): string[] {\n  return normalizeOrigins(\n    ([] as string[]).concat(\n      ...Object.keys(OPTIONAL_ORIGINS).map((k) => OPTIONAL_ORIGINS[k as OptionalFeature])\n    )\n  );\n}\n\n/** Dedupe and sort for stable manifest/validation. */\nexport function normalizeOrigins(origins: string[]): string[] {\n  return [...new Set(origins)].filter(Boolean).sort();\n}\n", "/**\n * Optional host permissions by feature. Uses optionalOrigins as single source of truth.\n */\n\nimport type { OptionalFeature } from \"./shared/optionalOrigins\";\nimport { getOriginsForFeature, getAllOptionalOrigins } from \"./shared/optionalOrigins\";\n\nasync function hasOrigins(origins: string[]): Promise<boolean> {\n  if (!origins.length) return true;\n  try {\n    if (!chrome?.permissions?.contains) return false;\n    return await chrome.permissions.contains({ origins });\n  } catch {\n    return false;\n  }\n}\n\nasync function requestOrigins(origins: string[]): Promise<boolean> {\n  if (!origins.length) return true;\n  try {\n    if (!chrome?.permissions?.request) return false;\n    return await chrome.permissions.request({ origins });\n  } catch {\n    return false;\n  }\n}\n\nasync function removeOrigins(origins: string[]): Promise<boolean> {\n  if (!origins.length) return true;\n  try {\n    if (!chrome?.permissions?.remove) return false;\n    return await chrome.permissions.remove({ origins });\n  } catch {\n    return false;\n  }\n}\n\nexport async function hasOptionalHostPermissions(feature: OptionalFeature): Promise<boolean> {\n  const origins = getOriginsForFeature(feature);\n  return hasOrigins(origins);\n}\n\nexport async function requestOptionalHostPermissions(feature: OptionalFeature): Promise<boolean> {\n  const origins = getOriginsForFeature(feature);\n  return requestOrigins(origins);\n}\n\nexport async function removeOptionalHostPermissions(feature: OptionalFeature): Promise<boolean> {\n  const origins = getOriginsForFeature(feature);\n  return removeOrigins(origins);\n}\n\n/** Legacy: pass explicit origins (e.g. from getOriginsForFeatures). */\nexport async function hasOptionalHostPermissionsOrigins(origins: string[]): Promise<boolean> {\n  return hasOrigins(origins);\n}\n\nexport async function requestOptionalHostPermissionsOrigins(origins: string[]): Promise<boolean> {\n  return requestOrigins(origins);\n}\n\nexport async function removeOptionalHostPermissionsOrigins(origins: string[]): Promise<boolean> {\n  return removeOrigins(origins);\n}\n\n/** True only if all optional origins (all features) are granted. Used by legacy handlers. */\nexport async function hasOptionalHostPermissionsAll(): Promise<boolean> {\n  return hasOrigins(getAllOptionalOrigins());\n}\n", "/**\r\n * Onboarding: welcome, terms acceptance, and optional Cloud Intel / Telemetria (default OFF).\r\n * On accept: set termsAccepted, save cloudIntelOptIn and telemetryOptIn from checkboxes,\r\n * request optional permissions only if Cloud Intel is checked; then open Options.\r\n */\r\n\r\nimport { DEFAULT_SETTINGS } from \"./shared/types\";\r\nimport type { Settings } from \"./shared/types\";\r\nimport { safeStorageSet } from \"./runtimeSafe\";\r\nimport { requestOptionalHostPermissions } from \"./permissions\";\r\n\r\nconst acceptBtn = document.getElementById(\"sgOnbAccept\");\r\nconst refuseBtn = document.getElementById(\"sgOnbRefuse\");\r\nconst onbCloudIntel = document.getElementById(\"onbCloudIntel\") as HTMLInputElement | null;\r\nconst onbTelemetry = document.getElementById(\"onbTelemetry\") as HTMLInputElement | null;\r\nconst onbMessage = document.getElementById(\"onbMessage\") as HTMLElement | null;\r\n\r\nfunction showMessage(text: string, isError = false) {\r\n  if (!onbMessage) return;\r\n  onbMessage.textContent = text;\r\n  onbMessage.classList.toggle(\"sg-onb-message--error\", isError);\r\n  onbMessage.style.display = text ? \"block\" : \"none\";\r\n}\r\n\r\nasync function onAccept() {\r\n  if (!acceptBtn) return;\r\n  (acceptBtn as HTMLButtonElement).disabled = true;\r\n  showMessage(\"\");\r\n\r\n  try {\r\n    await new Promise<void>((resolve, reject) => {\r\n      chrome.storage.local.set(\r\n        { termsAccepted: true, installDate: Date.now() },\r\n        () => (chrome.runtime?.lastError ? reject(chrome.runtime.lastError) : resolve())\r\n      );\r\n    });\r\n\r\n    const cloudIntel = onbCloudIntel?.checked === true;\r\n    const telemetry = onbTelemetry?.checked === true;\r\n\r\n    const current = await new Promise<Settings>((resolve) => {\r\n      chrome.storage.sync.get(DEFAULT_SETTINGS, (r) => {\r\n        resolve((r as Settings) ?? DEFAULT_SETTINGS);\r\n      });\r\n    });\r\n\r\n    let cloudIntelFinal = false;\r\n    if (cloudIntel) {\r\n      const granted = await requestOptionalHostPermissions(\"cloudIntel\");\r\n      if (!granted) {\r\n        showMessage(\"Sem permiss\u00F5es, Cloud Intel permanecer\u00E1 desativado. Voc\u00EA pode ativar depois em Configura\u00E7\u00F5es.\", true);\r\n      } else {\r\n        cloudIntelFinal = true;\r\n      }\r\n    }\r\n\r\n    let telemetryFinal = false;\r\n    if (telemetry) {\r\n      const granted = await requestOptionalHostPermissions(\"telemetry\");\r\n      if (!granted) {\r\n        showMessage(\"Sem permiss\u00F5es, telemetria permanecer\u00E1 desativada. Voc\u00EA pode ativar depois em Configura\u00E7\u00F5es.\", true);\r\n      } else {\r\n        telemetryFinal = true;\r\n      }\r\n    }\r\n\r\n    const next: Settings = {\r\n      ...current,\r\n      cloudIntelOptIn: cloudIntelFinal,\r\n      telemetryOptIn: telemetryFinal,\r\n    };\r\n    await safeStorageSet(next as unknown as Record<string, unknown>);\r\n  } catch {\r\n    showMessage(\"Erro ao salvar. Tente novamente em Configura\u00E7\u00F5es.\", true);\r\n    (acceptBtn as HTMLButtonElement).disabled = false;\r\n    return;\r\n  }\r\n\r\n  try {\r\n    if (typeof chrome.runtime?.openOptionsPage === \"function\") {\r\n      chrome.runtime.openOptionsPage();\r\n    } else {\r\n      const url = typeof chrome.runtime?.getURL === \"function\"\r\n        ? chrome.runtime.getURL(\"options.html\")\r\n        : \"options.html\";\r\n      if (typeof chrome?.tabs?.create === \"function\") {\r\n        chrome.tabs.create({ url });\r\n      } else {\r\n        window.location.href = url;\r\n      }\r\n    }\r\n    try {\r\n      window.close();\r\n    } catch {}\r\n  } catch {\r\n    const url = typeof chrome.runtime?.getURL === \"function\"\r\n      ? chrome.runtime.getURL(\"options.html\")\r\n      : \"options.html\";\r\n    window.location.href = url;\r\n  }\r\n}\r\n\r\nfunction onRefuse() {\r\n  if (!refuseBtn) return;\r\n  (refuseBtn as HTMLButtonElement).disabled = true;\r\n  try {\r\n    if (typeof chrome?.runtime?.getURL === \"function\") {\r\n      chrome.tabs.create?.({ url: \"chrome://extensions/?id=\" + chrome.runtime.id });\r\n    }\r\n  } catch {\r\n    window.open(\"chrome://extensions/\", \"_blank\");\r\n  }\r\n  try {\r\n    window.close();\r\n  } catch {}\r\n}\r\n\r\nacceptBtn?.addEventListener(\"click\", () => void onAccept());\r\nrefuseBtn?.addEventListener(\"click\", () => onRefuse());\r\n"],
  "mappings": "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",
  "names": []
}
