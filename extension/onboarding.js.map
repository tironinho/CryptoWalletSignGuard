{
  "version": 3,
  "sources": ["../src/shared/types.ts", "../src/services/telemetryService.ts", "../src/onboarding.ts"],
  "sourcesContent": ["export type WalletKind = \"EVM_INJECTED\" | \"SOLANA_INJECTED\" | \"UNKNOWN\";\nexport type WalletName =\n  | \"MetaMask\"\n  | \"Coinbase Wallet\"\n  | \"Trust\"\n  | \"Rabby\"\n  | \"OKX Wallet\"\n  | \"Binance Web3\"\n  | \"Rainbow\"\n  | \"Phantom\"\n  | \"Phantom EVM\"\n  | \"SafePal\"\n  | \"Bitget Wallet\"\n  | \"Brave Wallet\"\n  | \"Taho\"\n  | \"Ledger\"\n  | \"Frame\"\n  | \"MathWallet\"\n  | \"Solflare\"\n  | \"Backpack\"\n  | \"Injected\"\n  | \"EVM Wallet\"\n  | \"Unknown\";\n\nexport type WalletMeta = { id: string; name: string; iconHint?: string };\n\nexport type WalletBrand =\n  | \"MetaMask\"\n  | \"Coinbase Wallet\"\n  | \"Rabby\"\n  | \"Trust Wallet\"\n  | \"Brave Wallet\"\n  | \"OKX Wallet\"\n  | \"Binance Web3\"\n  | \"Bitget Wallet\"\n  | \"Phantom EVM\"\n  | \"EVM Wallet\";\n\nexport type WalletInfo = {\n  kind: WalletKind;\n  name: WalletName;\n  flags?: Record<string, boolean>;\n  walletBrand?: WalletBrand;\n  /** Display name for overlay (e.g. \"MetaMask\", \"EVM Wallet\") */\n  walletName?: string;\n};\n\nexport type EthRequest = {\n  method: string;\n  params?: any[];\n  // optional extra debugging/shape info from legacy provider entrypoints\n  rawShape?: string;\n  raw?: any;\n};\n\nexport type PendingRequestPayload = {\n  id: string;\n  url: string;\n  origin: string;\n  wallet?: WalletInfo | WalletMeta;\n  request: { method: string; params?: any[] };\n  providerTag?: string;\n  providerKey?: string;\n  providerSource?: \"window.ethereum\" | \"ethereum.providers[i]\" | \"eip6963\";\n};\n\nexport type FeeEstimateWire = {\n  ok: boolean;\n  gasLimitHex?: string;\n  feeLikelyWeiHex?: string;\n  feeMaxWeiHex?: string;\n  feeEstimated?: boolean;\n  feeReasonKey?: string;\n  error?: string;\n};\n\nexport type TxContextKind = \"SWITCH_NETWORK\" | \"NFT_PURCHASE\" | \"TOKEN_SWAP\" | \"VALUE_TRANSFER\" | \"CONTRACT_CALL\" | \"APPROVAL\";\n\nexport type AnalyzeRequest = {\n  requestId: string;\n  url: string;\n  origin: string;\n  request: EthRequest;\n  tabId?: number;\n  wallet?: WalletInfo;\n  providerHint?: { kind: ProviderKind; name?: string };\n  txCostPreview?: TxCostPreview;\n  feeEstimate?: FeeEstimateWire;\n  meta?: {\n    chainId?: string;\n    chainIdHex?: string;\n    chainIdRequested?: string;\n    txContext?: { kind: TxContextKind };\n    preflight?: {\n      tx?: any;\n      valueWei?: string; // decimal\n      valueEth?: string; // decimal\n      gasEstimate?: string; // hex\n      gasPrice?: string; // hex\n      feeWeiEstimated?: string; // decimal\n      feeEthEstimated?: string; // decimal\n      totalEthEstimated?: string; // decimal\n    }\n  };\n};\n\nexport type SecurityMode = \"STRICT\" | \"BALANCED\" | \"RELAXED\" | \"OFF\";\nexport type ProviderKind = \"EIP6963\" | \"METAMASK\" | \"RABBY\" | \"COINBASE\" | \"PHANTOM\" | \"UNKNOWN\";\n\nexport type ChainIdHex = string; // ex \"0x1\"\nexport type Address = string; // \"0x...\" lowercase\n\n/** Domain list decision for risk/UX (whitelist never auto-allows tx). */\nexport type DomainDecision = \"TRUSTED\" | \"BLOCKED\" | \"UNKNOWN\";\n\n/** Cache key for scam token: chainId:tokenAddressLower */\nexport type ScamTokenKey = `${string}:${string}`;\n\nexport type ListSourceName = \"metamask\" | \"scamsniffer\" | \"cryptoscamdb\" | \"dappradar\" | \"mew\" | \"seed\" | \"user\";\n\nexport type ListsCacheV1 = {\n  version: 1;\n  updatedAt: number;\n  sources: Record<ListSourceName, { updatedAt?: number; etag?: string; ok?: boolean; error?: string }>;\n  trustedDomains: string[];\n  blockedDomains: string[];\n  blockedAddresses: string[];\n  scamTokens: Array<{ chainId: string; address: string; symbol?: string; name?: string; source?: ListSourceName }>;\n  userTrustedDomains: string[];\n  userBlockedDomains: string[];\n  userBlockedAddresses: string[];\n  userScamTokens: Array<{ chainId: string; address: string; symbol?: string; name?: string }>;\n  userTrustedTokens: Array<{ chainId: string; address: string }>;\n};\n\nexport type ThreatIntelAddress = {\n  address: Address;\n  chainId?: ChainIdHex;\n  label: string;\n  category: \"DRAINER\" | \"SCAM_TOKEN\" | \"SCAM_ROUTER\" | \"MALICIOUS_SPENDER\" | \"UNKNOWN\";\n  sourceId: string;\n  confidence: 1 | 2 | 3;\n  updatedAt: number;\n};\n\nexport type ThreatIntelBundle = {\n  updatedAt: number;\n  sources: Array<{ id: string; url?: string; ok: boolean; fetchedAt: number; error?: string }>;\n  trustedDomainsSeed: string[];\n  blockedDomains: string[];\n  blockedAddresses: ThreatIntelAddress[];\n};\n\nexport type AssetInfo = {\n  chainId: ChainIdHex;\n  address: Address;\n  kind: \"ERC20\" | \"ERC721\" | \"ERC1155\" | \"UNKNOWN\";\n  name?: string;\n  symbol?: string;\n  decimals?: number;\n  fetchedAt: number;\n};\n\nexport type DecodedAction =\n  | { kind: \"APPROVE_ERC20\"; token: Address; spender: Address; amountType: \"LIMITED\" | \"UNLIMITED\"; amountRaw?: string }\n  | { kind: \"TRANSFER_ERC20\"; token: Address; to: Address; amountRaw?: string }\n  | { kind: \"TRANSFERFROM_ERC20\"; token: Address; from: Address; to: Address; amountRaw?: string }\n  | { kind: \"SET_APPROVAL_FOR_ALL\"; token: Address; operator: Address; approved: boolean }\n  | { kind: \"TRANSFER_NFT\"; token: Address; to: Address; from?: Address; tokenIdRaw?: string; amountRaw?: string; standard: \"ERC721\" | \"ERC1155\" | \"UNKNOWN\"; batch?: boolean }\n  | { kind: \"PERMIT_EIP2612\"; token: Address; spender: Address; valueType: \"LIMITED\" | \"UNLIMITED\"; valueRaw?: string; deadlineRaw?: string }\n  | { kind: \"UNKNOWN\"; selector?: string };\n\nexport type RiskLevel = \"LOW\" | \"WARN\" | \"HIGH\";\n\nexport type Recommend = \"ALLOW\" | \"WARN\" | \"HIGH\" | \"BLOCK\";\n\nexport type CheckKey =\n  | \"DOMAIN_INTEL\"\n  | \"LOOKALIKE\"\n  | \"TX_DECODE\"\n  | \"FEE_ESTIMATE\"\n  | \"ADDRESS_INTEL\"\n  | \"ASSET_ENRICH\"\n  | \"CLOUD_INTEL\";\n\nexport type CheckStatus = \"PASS\" | \"WARN\" | \"FAIL\" | \"SKIP\";\n\nexport interface CheckResult {\n  key: CheckKey;\n  status: CheckStatus;\n  noteKey?: string;\n}\n\nexport type DecodedKind =\n  | \"APPROVE\"\n  | \"SET_APPROVAL_FOR_ALL\"\n  | \"TYPED_DATA\"\n  | \"TX\"\n  | \"CONNECT\"\n  | \"SIGN\";\n\nexport type Decoded = {\n  kind: DecodedKind;\n  tokenOrCollection?: string;\n  spenderOrOperator?: string;\n  amountHuman?: string;\n  raw?: any;\n};\n\nexport type TrustVerdict = \"LIKELY_OFFICIAL\" | \"UNKNOWN\" | \"SUSPICIOUS\";\n\nexport type TrustAnalysis = {\n  verdict: TrustVerdict;\n  trustScore: number; // 0-100\n  reasons: string[];\n  matchedAllowlistDomain?: string;\n};\n\nexport type HumanExplanation = {\n  methodTitle: string;\n  methodShort: string;\n  methodWhy: string;\n  whatItDoes?: string[];\n  siteSees?: string[];\n  notHappen?: string[];\n  whyAsked?: string[];\n  risks: string[];\n  safeNotes: string[];\n  safe?: string[];\n  nextSteps: string[];\n  recommendation: string;\n  links?: Array<{ text: string; href: string }>;\n};\n\nexport type ThreatIntel = {\n  updatedAt: number;\n  sources: Array<{ id: string; url: string; ok: boolean; fetchedAt: number; error?: string }>;\n  trustedDomains: string[];\n  blockedDomains: string[];\n};\n\nexport type TxCostPreview = {\n  valueWei: string;                 // decimal string\n  feeEstimated: boolean;\n  gasLimitWei?: string;             // decimal string (gasLimit as bigint)\n  feeLikelyWei?: string;            // decimal string\n  feeMaxWei?: string;               // decimal string\n  totalLikelyWei?: string;          // decimal string\n  totalMaxWei?: string;             // decimal string\n  feeReasonKey?: string;            // i18n key when feeEstimated=false\n  /** USD per 1 unit of native token (for overlay). */\n  usdPerNative?: number;\n};\n\nexport type TxSummary = {\n  to?: string;\n  valueWei?: string;        // decimal\n  valueEth?: string;        // formatted\n  selector?: string;        // 0x + 8 hex\n  gasLimit?: string;        // decimal\n  maxFeePerGasWei?: string; // decimal\n  maxPriorityFeePerGasWei?: string; // decimal (EIP-1559 tip)\n  maxGasFeeEth?: string;    // ETH\n  maxTotalEth?: string;     // ETH (value + maxGasFee)\n  feeKnown?: boolean;\n  contractNameHint?: string;\n  dataLen?: number;         // raw data length\n};\n\nexport type Intent = \"NFT_PURCHASE\" | \"SWAP\" | \"APPROVAL\" | \"SEND\" | \"ETH_TRANSFER\" | \"TOKEN_TRANSFER\" | \"NFT_TRANSFER\" | \"CONTRACT_INTERACTION\" | \"CONNECT\" | \"SIGN\" | \"SIGNATURE\" | \"TYPED_DATA\" | \"CHAIN\" | \"SWITCH_CHAIN\" | \"ADD_CHAIN\" | \"WATCH_ASSET\" | \"SOLANA\" | \"UNKNOWN\";\n\nexport type TxExtras =\n  | {\n      approvalType: \"ERC20_APPROVE\";\n      tokenContract?: string;\n      spender?: string;\n      unlimited?: boolean;\n    }\n  | {\n      approvalType: \"NFT_SET_APPROVAL_FOR_ALL\";\n      tokenContract?: string;\n      operator?: string;\n      unlimited?: boolean;\n    }\n  | {\n      approvalType?: \"NFT_TRANSFER\";\n      tokenContract?: string;\n      toAddress?: string;\n    };\n\nexport type Analysis = {\n  level: RiskLevel;\n  score: number; // 0-100\n  title: string;\n  reasons: string[];\n  decoded?: Decoded;\n  decodedAction?: DecodedAction;\n  recommend: Recommend;\n  trust?: TrustAnalysis;\n  human?: HumanExplanation;\n  suggestedTrustedDomains?: string[];\n  tx?: TxSummary;\n  txCostPreview?: TxCostPreview;\n  txExtras?: TxExtras;\n  intent?: Intent;\n  txContext?: { kind: TxContextKind };\n  chainTarget?: { chainIdHex: string; chainName?: string };\n  addChainInfo?: { chainId: string; chainName?: string; rpcUrls?: string[]; nativeCurrencySymbol?: string };\n  watchAssetInfo?: { type: string; address?: string; symbol?: string; decimals?: number; image?: string };\n  wallet?: WalletInfo;\n  safeDomain?: boolean;\n  isPhishing?: boolean;\n  domainRisk?: { scoreDelta: number; reasons: string[] };\n  addressRisk?: { flagged: boolean; reasons: string[]; matches?: string[] };\n  method?: string;\n  asset?: AssetInfo;\n  flaggedAddress?: ThreatIntelAddress;\n  provider?: { kind: ProviderKind; name?: string };\n  feeGtValue?: boolean;\n  /** Checks performed (security coverage). */\n  checks?: CheckResult[];\n  /** Coverage summary: performed/total, limited when some checks unavailable. */\n  coverage?: { performed: number; total: number; limited: boolean };\n  /** i18n key for main verdict label (e.g. verdict_ok, verdict_warn, verdict_high, verdict_block). */\n  verdictLabelKey?: string;\n  /** When tx.to is a contract (eth_getCode !== \"0x\"). */\n  toIsContract?: boolean;\n  /** Verification level: FULL = intel fresh, LOCAL = cached, BASIC = no intel. */\n  verificationLevel?: \"FULL\" | \"LOCAL\" | \"BASIC\";\n  /** Timestamp of cached intel used (if any). */\n  verificationUpdatedAt?: number;\n  /** true when domain trusted/allowlisted + no flags + no suspicious addr. */\n  knownSafe?: boolean;\n  /** true when phishing/lookalike HIGH + blacklist. */\n  knownBad?: boolean;\n  /** Domain-related signals, e.g. METAMASK_SEED, BLACKLIST_HIT, LOOKALIKE, PUNYCODE, SEED_MATCH, SUSPICIOUS_TLD. */\n  domainSignals?: string[];\n  /** Intel source ids used, e.g. metamask, cryptoscamdb, scamsniffer, local_seed. */\n  intelSources?: string[];\n  /** List manager domain decision: TRUSTED / BLOCKED / UNKNOWN (for site reputation badge). */\n  domainListDecision?: DomainDecision;\n  /** Extras from typed-data (e.g. Permit: spender, value, deadline). */\n  typedDataExtras?: { spender?: string; value?: string; deadline?: string };\n  /** true when any address (to/spender/operator/tokenContract) matched address intel labels. */\n  addressIntelHit?: boolean;\n  /** Labels per role when address intel hit (human-readable label strings). */\n  addressIntel?: {\n    to?: string[];\n    spender?: string[];\n    operator?: string[];\n    tokenContract?: string[];\n  };\n  /** Result of Tenderly simulation (if run). SKIPPED when API failed (fallback). */\n  simulationOutcome?: {\n    status: \"SUCCESS\" | \"REVERT\" | \"RISK\" | \"SKIPPED\";\n    outgoingAssets: Array<{ symbol: string; amount: string; logo?: string }>;\n    incomingAssets: Array<{ symbol: string; amount: string; logo?: string }>;\n    gasUsed: string;\n    fallback?: boolean;\n    gasCostWei?: string;\n    isHighGas?: boolean;\n    simulated?: boolean;\n    message?: string;\n  };\n  /** True when simulation predicted revert (show \"ESTA TRANSA\u00C7\u00C3O VAI FALHAR\"). */\n  simulationRevert?: boolean;\n  /** Token confidence: SCAM, TRUSTED, LOW (new/unverified), UNKNOWN. */\n  tokenConfidence?: \"SCAM\" | \"TRUSTED\" | \"LOW\" | \"UNKNOWN\";\n  /** First-seen timestamp for token (when LOW/UNKNOWN). */\n  tokenFirstSeenAt?: number;\n  /** True when honeypot detected (buy but cannot sell / transfer). */\n  isHoneypot?: boolean;\n  /** True when protection is temporarily paused (allow without showing overlay). */\n  protectionPaused?: boolean;\n}\n\nexport type SupportedWalletEntry = { name: string; kind: string };\n\n/** User-configurable settings (spec name: UserSettings). */\nexport type Settings = {\n  riskWarnings: boolean;\n  showConnectOverlay: boolean;\n  blockHighRisk: boolean;\n  requireTypedOverride?: boolean;\n  allowOverrideOnPhishing?: boolean;\n  debugMode?: boolean;\n  domainChecks: boolean;\n  allowlist: string[];\n  trustedDomains?: string[];\n  customBlockedDomains?: string[];\n  customTrustedDomains?: string[];\n  enableIntel?: boolean;\n  mode?: SecurityMode;\n  supportedWalletsInfo?: SupportedWalletEntry[];\n  strictBlockApprovalsUnlimited?: boolean;\n  strictBlockSetApprovalForAll?: boolean;\n  strictBlockPermitLike?: boolean;\n  assetEnrichmentEnabled?: boolean;\n  addressIntelEnabled?: boolean;\n  /** P0-E: Allow external checks (more protection; may send domain/address for validation). Default false. */\n  cloudIntelOptIn?: boolean;\n  showUsd?: boolean;\n  planTier?: \"FREE\" | \"PRO\";\n  licenseKey?: string;\n  /** Cofre SignGuard: contracts that must not be transacted without explicit unlock. */\n  vault?: {\n    enabled: boolean;\n    lockedContracts: string[];\n  };\n  /** Tenderly simulation (no hardcoded keys). */\n  simulation?: {\n    enabled: boolean;\n    tenderlyAccount: string;\n    tenderlyProject: string;\n    tenderlyKey: string;\n  };\n  /** Pause protection until this timestamp (Date.now() + ms). */\n  pausedUntil?: number;\n  /** Domains that bypass overlay when protection is active (e.g. trusted tools). */\n  whitelistedDomains?: string[];\n  /** Modo Fortaleza: bloqueia todas as aprova\u00E7\u00F5es de tokens exceto em sites confi\u00E1veis. */\n  fortressMode?: boolean;\n  /** Expandir se\u00E7\u00F5es detalhadas (accordions) do overlay por padr\u00E3o. */\n  defaultExpandDetails?: boolean;\n};\n\n/** Alias for Settings (spec: UserSettings). */\nexport type UserSettings = Settings;\n\n/** Stored in chrome.storage.local key \"sg_plan\". */\nexport type PlanState = {\n  tier: \"FREE\" | \"PRO\";\n  keyMasked?: string;\n  activatedAt?: number;\n  expiresAt?: number;\n};\n\nexport const SUPPORTED_WALLETS: SupportedWalletEntry[] = [\n  { name: \"MetaMask\", kind: \"EVM\" },\n  { name: \"Coinbase Wallet\", kind: \"EVM\" },\n  { name: \"Trust Wallet\", kind: \"EVM\" },\n  { name: \"OKX Wallet\", kind: \"EVM\" },\n  { name: \"Binance Web3\", kind: \"EVM\" },\n  { name: \"Rabby\", kind: \"EVM\" },\n  { name: \"Rainbow\", kind: \"EVM\" },\n  { name: \"Phantom\", kind: \"EVM/Solana\" },\n  { name: \"Brave Wallet\", kind: \"EVM\" },\n  { name: \"Bitget Wallet\", kind: \"EVM\" },\n  { name: \"MathWallet\", kind: \"EVM\" },\n  { name: \"Solflare\", kind: \"Solana\" },\n  { name: \"Backpack\", kind: \"Solana\" },\n];\n\nexport const DEFAULT_SETTINGS: Settings = {\n  riskWarnings: true,\n  showConnectOverlay: true,\n  blockHighRisk: true,\n  requireTypedOverride: true,\n  allowOverrideOnPhishing: false,\n  debugMode: false,\n  domainChecks: true,\n  mode: \"BALANCED\",\n  strictBlockApprovalsUnlimited: true,\n  strictBlockSetApprovalForAll: true,\n  strictBlockPermitLike: true,\n  assetEnrichmentEnabled: true,\n  addressIntelEnabled: true,\n  cloudIntelOptIn: true,\n  showUsd: true,\n  defaultExpandDetails: true,\n  planTier: \"FREE\",\n  licenseKey: \"\",\n  trustedDomains: [\n    \"opensea.io\",\n    \"blur.io\",\n    \"app.uniswap.org\",\n    \"uniswap.org\",\n    \"looksrare.org\",\n    \"x2y2.io\",\n    \"etherscan.io\",\n    \"arbitrum.io\",\n    \"polygon.technology\",\n  ],\n  supportedWalletsInfo: SUPPORTED_WALLETS,\n  allowlist: [\n    \"opensea.io\",\n    \"blur.io\",\n    \"app.uniswap.org\",\n    \"uniswap.org\",\n    \"looksrare.org\",\n    \"x2y2.io\",\n    \"etherscan.io\",\n    \"arbitrum.io\",\n    \"polygon.technology\",\n  ],\n  customBlockedDomains: [],\n  customTrustedDomains: [],\n  enableIntel: true,\n  vault: {\n    enabled: false,\n    lockedContracts: [],\n  },\n  simulation: {\n    enabled: false,\n    tenderlyAccount: \"\",\n    tenderlyProject: \"\",\n    tenderlyKey: \"\",\n  },\n  whitelistedDomains: [],\n  fortressMode: false,\n};\n\n", "/**\r\n * Telemetry: REST-only Supabase (no @supabase/supabase-js) to avoid Service Worker crash in MV3.\r\n * Tables: installations, tx_logs, threat_reports. All failures are silent.\r\n */\r\n\r\nconst SUPABASE_URL = \"https://cjnzidctntqzamhwmwkt.supabase.co\";\r\nconst SUPABASE_KEY = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNqbnppZGN0bnRxemFtaHdtd2t0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA5MzIzNzQsImV4cCI6MjA4NjUwODM3NH0.NyUvGRPY1psOwpJytWG_d3IXwCwPxLtuSG6V1uX13mc\";\r\n\r\nconst INSTALL_ID_KEY = \"installId\";\r\n\r\ntype GetSettingsFn = () => Promise<import(\"../shared/types\").Settings>;\r\nlet getSettingsFn: GetSettingsFn | null = null;\r\n\r\nexport function initTelemetry(getSettings: GetSettingsFn): void {\r\n  getSettingsFn = getSettings;\r\n}\r\n\r\nasync function getTermsAccepted(): Promise<boolean> {\r\n  try {\r\n    const r = await new Promise<Record<string, boolean>>((resolve) => {\r\n      if (typeof chrome?.storage?.local?.get !== \"function\") return resolve({});\r\n      chrome.storage.local.get(\"termsAccepted\", (res) => {\r\n        resolve((res as Record<string, boolean>) ?? {});\r\n      });\r\n    });\r\n    return r?.termsAccepted === true;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\nasync function getOptIn(): Promise<boolean> {\r\n  if (!(await getTermsAccepted())) return false;\r\n  if (!getSettingsFn) return true;\r\n  try {\r\n    const s = await getSettingsFn();\r\n    return s?.cloudIntelOptIn !== false;\r\n  } catch {\r\n    return true;\r\n  }\r\n}\r\n\r\n/** Helper: POST to Supabase REST (no SDK). Fails silently. */\r\nasync function sendToSupabase(table: string, data: Record<string, unknown>): Promise<void> {\r\n  try {\r\n    if (typeof navigator !== \"undefined\" && !navigator.onLine) return;\r\n    await fetch(`${SUPABASE_URL}/rest/v1/${table}`, {\r\n      method: \"POST\",\r\n      headers: {\r\n        apikey: SUPABASE_KEY,\r\n        Authorization: `Bearer ${SUPABASE_KEY}`,\r\n        \"Content-Type\": \"application/json\",\r\n        Prefer: \"return=minimal\",\r\n      },\r\n      body: JSON.stringify(data),\r\n    });\r\n  } catch {\r\n    // silent\r\n  }\r\n}\r\n\r\nexport async function getOrCreateInstallationId(): Promise<string> {\r\n  return new Promise((resolve) => {\r\n    try {\r\n      if (typeof chrome?.storage?.local?.get !== \"function\") {\r\n        resolve(typeof crypto !== \"undefined\" && crypto.randomUUID ? crypto.randomUUID() : \"unknown\");\r\n        return;\r\n      }\r\n      chrome.storage.local.get(INSTALL_ID_KEY, (r) => {\r\n        if (chrome.runtime?.lastError) {\r\n          const id = typeof crypto !== \"undefined\" && crypto.randomUUID ? crypto.randomUUID() : \"unknown\";\r\n          chrome.storage.local.set({ [INSTALL_ID_KEY]: id }, () => resolve(id));\r\n          return;\r\n        }\r\n        const id = (r as Record<string, string>)?.[INSTALL_ID_KEY];\r\n        if (id && typeof id === \"string\") {\r\n          resolve(id);\r\n          return;\r\n        }\r\n        const newId = typeof crypto !== \"undefined\" && crypto.randomUUID ? crypto.randomUUID() : \"unknown\";\r\n        chrome.storage.local.set({ [INSTALL_ID_KEY]: newId }, () => resolve(newId));\r\n      });\r\n    } catch {\r\n      resolve(\"unknown\");\r\n    }\r\n  });\r\n}\r\n\r\nexport async function identifyUser(): Promise<string> {\r\n  try {\r\n    if (!(await getTermsAccepted())) return await getOrCreateInstallationId();\r\n    let uuid = await getOrCreateInstallationId();\r\n    if (uuid === \"unknown\") {\r\n      uuid = typeof crypto !== \"undefined\" && crypto.randomUUID ? crypto.randomUUID() : \"unknown\";\r\n      await new Promise<void>((resolve) => {\r\n        chrome.storage.local.set({ [INSTALL_ID_KEY]: uuid }, () => resolve());\r\n      });\r\n    }\r\n    if (await getOptIn()) {\r\n      await sendToSupabase(\"installations\", {\r\n        install_id: uuid,\r\n        user_agent: typeof navigator !== \"undefined\" ? navigator.userAgent : \"\",\r\n        language: typeof navigator !== \"undefined\" ? navigator.language : \"\",\r\n        timezone: typeof Intl !== \"undefined\" ? Intl.DateTimeFormat().resolvedOptions().timeZone : \"\",\r\n        last_active_at: new Date().toISOString(),\r\n      });\r\n    }\r\n    return uuid;\r\n  } catch {\r\n    return \"unknown\";\r\n  }\r\n}\r\n\r\nexport async function registerUser(): Promise<void> {\r\n  await identifyUser();\r\n}\r\n\r\nexport async function syncUserWallets(_wallets: string[]): Promise<void> {\r\n  // Optional: send to user_wallets table via sendToSupabase; no-op for stability\r\n}\r\n\r\nexport async function trackInterest(_category: string): Promise<void> {\r\n  if (!(await getOptIn())) return;\r\n  // Optional: batch to user_interests; no-op for stability\r\n}\r\n\r\nexport async function trackTransaction(txData: {\r\n  chain_id?: string;\r\n  chainId?: string;\r\n  asset_address?: string;\r\n  contractAddress?: string;\r\n  method?: string;\r\n  status?: string;\r\n  [k: string]: unknown;\r\n}): Promise<void> {\r\n  if (!(await getOptIn())) return;\r\n  try {\r\n    const installId = await getOrCreateInstallationId();\r\n    await sendToSupabase(\"tx_logs\", {\r\n      install_id: installId,\r\n      created_at: new Date().toISOString(),\r\n      chain_id: txData.chain_id ?? txData.chainId ? String(txData.chain_id ?? txData.chainId) : null,\r\n      asset_address: txData.asset_address ?? txData.contractAddress ?? null,\r\n      method: txData.method ?? \"unknown\",\r\n      status: txData.status ?? \"simulated\",\r\n    });\r\n  } catch {\r\n    // silent\r\n  }\r\n}\r\n\r\nexport async function trackTx(payload: {\r\n  chainId: string;\r\n  contractAddress: string;\r\n  method: string;\r\n  valueUsd?: number;\r\n}): Promise<void> {\r\n  await trackTransaction({\r\n    chain_id: payload.chainId,\r\n    asset_address: payload.contractAddress,\r\n    method: payload.method,\r\n    status: \"simulated\",\r\n  });\r\n}\r\n\r\nexport async function trackThreat(\r\n  url: string,\r\n  score: number,\r\n  reasons: string[],\r\n  metadata?: Record<string, unknown>\r\n): Promise<void> {\r\n  if (!(await getOptIn())) return;\r\n  try {\r\n    const installId = await getOrCreateInstallationId();\r\n    let domain = \"\";\r\n    try {\r\n      domain = new URL(url).hostname;\r\n    } catch {\r\n      domain = url?.slice(0, 256) ?? \"\";\r\n    }\r\n    await sendToSupabase(\"threat_reports\", {\r\n      install_id: installId,\r\n      url: url?.slice(0, 2048) ?? \"\",\r\n      domain,\r\n      risk_score: score,\r\n      risk_reason: Array.isArray(reasons) ? reasons.join(\", \") : \"Unknown\",\r\n      created_at: new Date().toISOString(),\r\n      ...(metadata && typeof metadata === \"object\" ? metadata : {}),\r\n    });\r\n  } catch {\r\n    // silent\r\n  }\r\n}\r\n\r\nexport async function reportThreat(threatData: {\r\n  url?: string;\r\n  score?: number;\r\n  reasons?: string[];\r\n  metadata?: Record<string, unknown>;\r\n}): Promise<void> {\r\n  await trackThreat(\r\n    threatData.url ?? \"\",\r\n    threatData.score ?? 100,\r\n    Array.isArray(threatData.reasons) ? threatData.reasons : [],\r\n    threatData.metadata\r\n  );\r\n}\r\n\r\nexport async function trackEvent(_eventName: string, _props?: Record<string, unknown>): Promise<void> {\r\n  if (!(await getOptIn())) return;\r\n  // Optional: usage_events; no-op for stability\r\n}\r\n\r\nexport async function trackSession(_data: { domain: string; referrer?: string; durationSec: number }): Promise<void> {\r\n  if (!(await getOptIn())) return;\r\n  // Optional: web3_sessions; no-op for stability\r\n}\r\n\r\nexport async function trackInteraction(_data: {\r\n  domain: string;\r\n  kind?: string;\r\n  props?: Record<string, unknown>;\r\n}): Promise<void> {\r\n  if (!(await getOptIn())) return;\r\n  // Optional: ui_interactions; no-op for stability\r\n}\r\n\r\nexport async function updateExtendedProfile(_data: Record<string, unknown>): Promise<void> {\r\n  // Placeholder to avoid callers breaking\r\n}\r\n\r\nexport const telemetry = {\r\n  identifyUser,\r\n  registerUser,\r\n  syncUserWallets,\r\n  trackInterest,\r\n  trackThreat,\r\n  reportThreat,\r\n  trackTransaction,\r\n  trackEvent,\r\n  trackTx,\r\n  trackSession,\r\n  trackInteraction,\r\n  updateExtendedProfile,\r\n};\r\n", "/**\r\n * Onboarding: welcome screen and terms acceptance.\r\n * On accept: persist termsAccepted, set cloudIntelOptIn, call registerUser(), redirect to options.\r\n */\r\n\r\nimport { DEFAULT_SETTINGS } from \"./shared/types\";\r\nimport type { Settings } from \"./shared/types\";\r\nimport { telemetry } from \"./services/telemetryService\";\r\n\r\nconst acceptBtn = document.getElementById(\"sgOnbAccept\");\r\nconst refuseBtn = document.getElementById(\"sgOnbRefuse\");\r\n\r\nasync function onAccept() {\r\n  if (!acceptBtn) return;\r\n  (acceptBtn as HTMLButtonElement).disabled = true;\r\n  try {\r\n    await new Promise<void>((resolve, reject) => {\r\n      chrome.storage.local.set(\r\n        { termsAccepted: true, installDate: Date.now() },\r\n        () => (chrome.runtime?.lastError ? reject(chrome.runtime.lastError) : resolve())\r\n      );\r\n    });\r\n    const current = await new Promise<Settings>((resolve) => {\r\n      chrome.storage.sync.get(DEFAULT_SETTINGS, (r) => {\r\n        resolve((r as Settings) ?? DEFAULT_SETTINGS);\r\n      });\r\n    });\r\n    await new Promise<void>((resolve, reject) => {\r\n      chrome.storage.sync.set(\r\n        { ...current, cloudIntelOptIn: true },\r\n        () => (chrome.runtime?.lastError ? reject(chrome.runtime.lastError) : resolve())\r\n      );\r\n    });\r\n    await telemetry.registerUser();\r\n  } catch {\r\n    // continue to redirect\r\n  }\r\n  try {\r\n    const url = typeof chrome.runtime?.getURL === \"function\"\r\n      ? chrome.runtime.getURL(\"options.html\")\r\n      : \"options.html\";\r\n    if (typeof chrome?.tabs?.getCurrent === \"function\") {\r\n      chrome.tabs.getCurrent((tab) => {\r\n        if (tab?.id != null && chrome.tabs?.update) {\r\n          chrome.tabs.update(tab.id, { url });\r\n        } else {\r\n          window.location.href = url;\r\n        }\r\n      });\r\n    } else {\r\n      window.location.href = url;\r\n    }\r\n  } catch {\r\n    window.location.href = \"options.html\";\r\n  }\r\n}\r\n\r\nfunction onRefuse() {\r\n  if (!refuseBtn) return;\r\n  (refuseBtn as HTMLButtonElement).disabled = true;\r\n  try {\r\n    if (typeof chrome?.runtime?.getURL === \"function\") {\r\n      chrome.tabs.create?.({ url: \"chrome://extensions/?id=\" + chrome.runtime.id });\r\n    }\r\n  } catch {\r\n    window.open(\"chrome://extensions/\", \"_blank\");\r\n  }\r\n  try {\r\n    window.close();\r\n  } catch {}\r\n}\r\n\r\nacceptBtn?.addEventListener(\"click\", () => void onAccept());\r\nrefuseBtn?.addEventListener(\"click\", () => onRefuse());\r\n"],
  "mappings": "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",
  "names": ["id"]
}
