{
  "version": 3,
  "sources": ["../../src/shared/types.ts", "../../src/runtimeSafe.ts", "../../src/dashboard/dashboard.ts"],
  "sourcesContent": ["export type WalletKind = \"EVM_INJECTED\" | \"SOLANA_INJECTED\" | \"UNKNOWN\";\nexport type WalletName =\n  | \"MetaMask\"\n  | \"Coinbase Wallet\"\n  | \"Trust\"\n  | \"Rabby\"\n  | \"OKX Wallet\"\n  | \"Binance Web3\"\n  | \"Rainbow\"\n  | \"Phantom\"\n  | \"Phantom EVM\"\n  | \"SafePal\"\n  | \"Bitget Wallet\"\n  | \"Brave Wallet\"\n  | \"Taho\"\n  | \"Ledger\"\n  | \"Frame\"\n  | \"MathWallet\"\n  | \"Solflare\"\n  | \"Backpack\"\n  | \"Injected\"\n  | \"EVM Wallet\"\n  | \"Unknown\";\n\nexport type WalletMeta = { id: string; name: string; iconHint?: string };\n\nexport type WalletBrand =\n  | \"MetaMask\"\n  | \"Coinbase Wallet\"\n  | \"Rabby\"\n  | \"Trust Wallet\"\n  | \"Brave Wallet\"\n  | \"OKX Wallet\"\n  | \"Binance Web3\"\n  | \"Bitget Wallet\"\n  | \"Phantom EVM\"\n  | \"EVM Wallet\";\n\nexport type WalletInfo = {\n  kind: WalletKind;\n  name: WalletName;\n  flags?: Record<string, boolean>;\n  walletBrand?: WalletBrand;\n  /** Display name for overlay (e.g. \"MetaMask\", \"EVM Wallet\") */\n  walletName?: string;\n};\n\nexport type EthRequest = {\n  method: string;\n  params?: any[];\n  // optional extra debugging/shape info from legacy provider entrypoints\n  rawShape?: string;\n  raw?: any;\n};\n\nexport type PendingRequestPayload = {\n  id: string;\n  url: string;\n  origin: string;\n  wallet?: WalletInfo | WalletMeta;\n  request: { method: string; params?: any[] };\n  providerTag?: string;\n  providerKey?: string;\n  providerSource?: \"window.ethereum\" | \"ethereum.providers[i]\" | \"eip6963\";\n};\n\nexport type AnalyzeRequest = {\n  requestId: string;\n  url: string;\n  origin: string;\n  request: EthRequest;\n  tabId?: number;\n  wallet?: WalletInfo;\n  providerHint?: { kind: ProviderKind; name?: string };\n  txCostPreview?: TxCostPreview;\n  meta?: {\n    chainId?: string;\n    chainIdHex?: string;\n    chainIdRequested?: string;\n    preflight?: {\n      tx?: any;\n      valueWei?: string; // decimal\n      valueEth?: string; // decimal\n      gasEstimate?: string; // hex\n      gasPrice?: string; // hex\n      feeWeiEstimated?: string; // decimal\n      feeEthEstimated?: string; // decimal\n      totalEthEstimated?: string; // decimal\n    }\n  };\n};\n\nexport type SecurityMode = \"STRICT\" | \"BALANCED\" | \"RELAXED\" | \"OFF\";\nexport type ProviderKind = \"EIP6963\" | \"METAMASK\" | \"RABBY\" | \"COINBASE\" | \"PHANTOM\" | \"UNKNOWN\";\n\nexport type ChainIdHex = string; // ex \"0x1\"\nexport type Address = string; // \"0x...\" lowercase\n\n/** Domain list decision for risk/UX (whitelist never auto-allows tx). */\nexport type DomainDecision = \"TRUSTED\" | \"BLOCKED\" | \"UNKNOWN\";\n\n/** Cache key for scam token: chainId:tokenAddressLower */\nexport type ScamTokenKey = `${string}:${string}`;\n\nexport type ListSourceName = \"metamask\" | \"scamsniffer\" | \"cryptoscamdb\" | \"dappradar\" | \"mew\" | \"seed\" | \"user\";\n\nexport type ListsCacheV1 = {\n  version: 1;\n  updatedAt: number;\n  sources: Record<ListSourceName, { updatedAt?: number; etag?: string; ok?: boolean; error?: string }>;\n  trustedDomains: string[];\n  blockedDomains: string[];\n  blockedAddresses: string[];\n  scamTokens: Array<{ chainId: string; address: string; symbol?: string; name?: string; source?: ListSourceName }>;\n  userTrustedDomains: string[];\n  userBlockedDomains: string[];\n  userBlockedAddresses: string[];\n  userScamTokens: Array<{ chainId: string; address: string; symbol?: string; name?: string }>;\n};\n\nexport type ThreatIntelAddress = {\n  address: Address;\n  chainId?: ChainIdHex;\n  label: string;\n  category: \"DRAINER\" | \"SCAM_TOKEN\" | \"SCAM_ROUTER\" | \"MALICIOUS_SPENDER\" | \"UNKNOWN\";\n  sourceId: string;\n  confidence: 1 | 2 | 3;\n  updatedAt: number;\n};\n\nexport type ThreatIntelBundle = {\n  updatedAt: number;\n  sources: Array<{ id: string; url?: string; ok: boolean; fetchedAt: number; error?: string }>;\n  trustedDomainsSeed: string[];\n  blockedDomains: string[];\n  blockedAddresses: ThreatIntelAddress[];\n};\n\nexport type AssetInfo = {\n  chainId: ChainIdHex;\n  address: Address;\n  kind: \"ERC20\" | \"ERC721\" | \"ERC1155\" | \"UNKNOWN\";\n  name?: string;\n  symbol?: string;\n  decimals?: number;\n  fetchedAt: number;\n};\n\nexport type DecodedAction =\n  | { kind: \"APPROVE_ERC20\"; token: Address; spender: Address; amountType: \"LIMITED\" | \"UNLIMITED\"; amountRaw?: string }\n  | { kind: \"TRANSFER_ERC20\"; token: Address; to: Address; amountRaw?: string }\n  | { kind: \"TRANSFERFROM_ERC20\"; token: Address; from: Address; to: Address; amountRaw?: string }\n  | { kind: \"SET_APPROVAL_FOR_ALL\"; token: Address; operator: Address; approved: boolean }\n  | { kind: \"TRANSFER_NFT\"; token: Address; to: Address; from?: Address; tokenIdRaw?: string; amountRaw?: string; standard: \"ERC721\" | \"ERC1155\" | \"UNKNOWN\"; batch?: boolean }\n  | { kind: \"PERMIT_EIP2612\"; token: Address; spender: Address; valueType: \"LIMITED\" | \"UNLIMITED\"; valueRaw?: string; deadlineRaw?: string }\n  | { kind: \"UNKNOWN\"; selector?: string };\n\nexport type RiskLevel = \"LOW\" | \"WARN\" | \"HIGH\";\n\nexport type Recommend = \"ALLOW\" | \"WARN\" | \"HIGH\" | \"BLOCK\";\n\nexport type CheckKey =\n  | \"DOMAIN_INTEL\"\n  | \"LOOKALIKE\"\n  | \"TX_DECODE\"\n  | \"FEE_ESTIMATE\"\n  | \"ADDRESS_INTEL\"\n  | \"ASSET_ENRICH\"\n  | \"CLOUD_INTEL\";\n\nexport type CheckStatus = \"PASS\" | \"WARN\" | \"FAIL\" | \"SKIP\";\n\nexport interface CheckResult {\n  key: CheckKey;\n  status: CheckStatus;\n  noteKey?: string;\n}\n\nexport type DecodedKind =\n  | \"APPROVE\"\n  | \"SET_APPROVAL_FOR_ALL\"\n  | \"TYPED_DATA\"\n  | \"TX\"\n  | \"CONNECT\"\n  | \"SIGN\";\n\nexport type Decoded = {\n  kind: DecodedKind;\n  tokenOrCollection?: string;\n  spenderOrOperator?: string;\n  amountHuman?: string;\n  raw?: any;\n};\n\nexport type TrustVerdict = \"LIKELY_OFFICIAL\" | \"UNKNOWN\" | \"SUSPICIOUS\";\n\nexport type TrustAnalysis = {\n  verdict: TrustVerdict;\n  trustScore: number; // 0-100\n  reasons: string[];\n  matchedAllowlistDomain?: string;\n};\n\nexport type HumanExplanation = {\n  methodTitle: string;\n  methodShort: string;\n  methodWhy: string;\n  whatItDoes?: string[];\n  siteSees?: string[];\n  notHappen?: string[];\n  whyAsked?: string[];\n  risks: string[];\n  safeNotes: string[];\n  nextSteps: string[];\n  recommendation: string;\n  links?: Array<{ text: string; href: string }>;\n};\n\nexport type ThreatIntel = {\n  updatedAt: number;\n  sources: Array<{ id: string; url: string; ok: boolean; fetchedAt: number; error?: string }>;\n  trustedDomains: string[];\n  blockedDomains: string[];\n};\n\nexport type TxCostPreview = {\n  valueWei: string;                 // decimal string\n  feeEstimated: boolean;\n  gasLimitWei?: string;             // decimal string (gasLimit as bigint)\n  feeLikelyWei?: string;            // decimal string\n  feeMaxWei?: string;               // decimal string\n  totalLikelyWei?: string;          // decimal string\n  totalMaxWei?: string;             // decimal string\n  feeReasonKey?: string;            // i18n key when feeEstimated=false\n};\n\nexport type TxSummary = {\n  to?: string;\n  valueWei?: string;        // decimal\n  valueEth?: string;        // formatted\n  selector?: string;        // 0x + 8 hex\n  gasLimit?: string;        // decimal\n  maxFeePerGasWei?: string; // decimal\n  maxGasFeeEth?: string;    // ETH\n  maxTotalEth?: string;     // ETH (value + maxGasFee)\n  feeKnown?: boolean;\n  contractNameHint?: string;\n};\n\nexport type Intent = \"NFT_PURCHASE\" | \"SWAP\" | \"APPROVAL\" | \"SEND\" | \"ETH_TRANSFER\" | \"TOKEN_TRANSFER\" | \"NFT_TRANSFER\" | \"CONTRACT_INTERACTION\" | \"CONNECT\" | \"SIGN\" | \"SIGNATURE\" | \"TYPED_DATA\" | \"CHAIN\" | \"SWITCH_CHAIN\" | \"ADD_CHAIN\" | \"WATCH_ASSET\" | \"SOLANA\" | \"UNKNOWN\";\n\nexport type TxExtras =\n  | {\n      approvalType: \"ERC20_APPROVE\";\n      tokenContract?: string;\n      spender?: string;\n      unlimited?: boolean;\n    }\n  | {\n      approvalType: \"NFT_SET_APPROVAL_FOR_ALL\";\n      tokenContract?: string;\n      operator?: string;\n      unlimited?: boolean;\n    }\n  | {\n      approvalType?: \"NFT_TRANSFER\";\n      tokenContract?: string;\n      toAddress?: string;\n    };\n\nexport type Analysis = {\n  level: RiskLevel;\n  score: number; // 0-100\n  title: string;\n  reasons: string[];\n  decoded?: Decoded;\n  decodedAction?: DecodedAction;\n  recommend: Recommend;\n  trust?: TrustAnalysis;\n  human?: HumanExplanation;\n  suggestedTrustedDomains?: string[];\n  tx?: TxSummary;\n  txCostPreview?: TxCostPreview;\n  txExtras?: TxExtras;\n  intent?: Intent;\n  chainTarget?: { chainIdHex: string; chainName?: string };\n  addChainInfo?: { chainId: string; chainName?: string; rpcUrls?: string[]; nativeCurrencySymbol?: string };\n  watchAssetInfo?: { type: string; address?: string; symbol?: string; decimals?: number; image?: string };\n  wallet?: WalletInfo;\n  safeDomain?: boolean;\n  isPhishing?: boolean;\n  domainRisk?: { scoreDelta: number; reasons: string[] };\n  addressRisk?: { flagged: boolean; reasons: string[]; matches?: string[] };\n  method?: string;\n  asset?: AssetInfo;\n  flaggedAddress?: ThreatIntelAddress;\n  provider?: { kind: ProviderKind; name?: string };\n  feeGtValue?: boolean;\n  /** Checks performed (security coverage). */\n  checks?: CheckResult[];\n  /** Coverage summary: performed/total, limited when some checks unavailable. */\n  coverage?: { performed: number; total: number; limited: boolean };\n  /** i18n key for main verdict label (e.g. verdict_ok, verdict_warn, verdict_high, verdict_block). */\n  verdictLabelKey?: string;\n  /** When tx.to is a contract (eth_getCode !== \"0x\"). */\n  toIsContract?: boolean;\n  /** Verification level: FULL = intel fresh, LOCAL = cached, BASIC = no intel. */\n  verificationLevel?: \"FULL\" | \"LOCAL\" | \"BASIC\";\n  /** Timestamp of cached intel used (if any). */\n  verificationUpdatedAt?: number;\n  /** true when domain trusted/allowlisted + no flags + no suspicious addr. */\n  knownSafe?: boolean;\n  /** true when phishing/lookalike HIGH + blacklist. */\n  knownBad?: boolean;\n  /** Domain-related signals, e.g. METAMASK_SEED, BLACKLIST_HIT, LOOKALIKE, PUNYCODE, SEED_MATCH, SUSPICIOUS_TLD. */\n  domainSignals?: string[];\n  /** Intel source ids used, e.g. metamask, cryptoscamdb, scamsniffer, local_seed. */\n  intelSources?: string[];\n  /** List manager domain decision: TRUSTED / BLOCKED / UNKNOWN (for site reputation badge). */\n  domainListDecision?: DomainDecision;\n  /** Extras from typed-data (e.g. Permit: spender, value, deadline). */\n  typedDataExtras?: { spender?: string; value?: string; deadline?: string };\n  /** true when any address (to/spender/operator/tokenContract) matched address intel labels. */\n  addressIntelHit?: boolean;\n  /** Labels per role when address intel hit (human-readable label strings). */\n  addressIntel?: {\n    to?: string[];\n    spender?: string[];\n    operator?: string[];\n    tokenContract?: string[];\n  };\n  /** Result of Tenderly simulation (if run). SKIPPED when API failed (fallback). */\n  simulationOutcome?: {\n    status: \"SUCCESS\" | \"REVERT\" | \"RISK\" | \"SKIPPED\";\n    outgoingAssets: Array<{ symbol: string; amount: string; logo?: string }>;\n    incomingAssets: Array<{ symbol: string; amount: string; logo?: string }>;\n    gasUsed: string;\n    fallback?: boolean;\n    gasCostWei?: string;\n    isHighGas?: boolean;\n    simulated?: boolean;\n    message?: string;\n  };\n  /** True when simulation predicted revert (show \"ESTA TRANSA\u00C7\u00C3O VAI FALHAR\"). */\n  simulationRevert?: boolean;\n  /** True when honeypot detected (buy but cannot sell / transfer). */\n  isHoneypot?: boolean;\n  /** True when protection is temporarily paused (allow without showing overlay). */\n  protectionPaused?: boolean;\n}\n\nexport type SupportedWalletEntry = { name: string; kind: string };\n\n/** User-configurable settings (spec name: UserSettings). */\nexport type Settings = {\n  riskWarnings: boolean;\n  showConnectOverlay: boolean;\n  blockHighRisk: boolean;\n  requireTypedOverride?: boolean;\n  allowOverrideOnPhishing?: boolean;\n  debugMode?: boolean;\n  domainChecks: boolean;\n  allowlist: string[];\n  trustedDomains?: string[];\n  customBlockedDomains?: string[];\n  customTrustedDomains?: string[];\n  enableIntel?: boolean;\n  mode?: SecurityMode;\n  supportedWalletsInfo?: SupportedWalletEntry[];\n  strictBlockApprovalsUnlimited?: boolean;\n  strictBlockSetApprovalForAll?: boolean;\n  strictBlockPermitLike?: boolean;\n  assetEnrichmentEnabled?: boolean;\n  addressIntelEnabled?: boolean;\n  /** P0-E: Allow external checks (more protection; may send domain/address for validation). Default false. */\n  cloudIntelOptIn?: boolean;\n  showUsd?: boolean;\n  planTier?: \"FREE\" | \"PRO\";\n  licenseKey?: string;\n  /** Cofre SignGuard: contracts that must not be transacted without explicit unlock. */\n  vault?: {\n    enabled: boolean;\n    lockedContracts: string[];\n  };\n  /** Tenderly simulation (no hardcoded keys). */\n  simulation?: {\n    enabled: boolean;\n    tenderlyAccount: string;\n    tenderlyProject: string;\n    tenderlyKey: string;\n  };\n  /** Pause protection until this timestamp (Date.now() + ms). */\n  pausedUntil?: number;\n  /** Domains that bypass overlay when protection is active (e.g. trusted tools). */\n  whitelistedDomains?: string[];\n  /** Modo Fortaleza: bloqueia todas as aprova\u00E7\u00F5es de tokens exceto em sites confi\u00E1veis. */\n  fortressMode?: boolean;\n};\n\n/** Alias for Settings (spec: UserSettings). */\nexport type UserSettings = Settings;\n\n/** Stored in chrome.storage.local key \"sg_plan\". */\nexport type PlanState = {\n  tier: \"FREE\" | \"PRO\";\n  keyMasked?: string;\n  activatedAt?: number;\n  expiresAt?: number;\n};\n\nexport const SUPPORTED_WALLETS: SupportedWalletEntry[] = [\n  { name: \"MetaMask\", kind: \"EVM\" },\n  { name: \"Coinbase Wallet\", kind: \"EVM\" },\n  { name: \"Trust Wallet\", kind: \"EVM\" },\n  { name: \"OKX Wallet\", kind: \"EVM\" },\n  { name: \"Binance Web3\", kind: \"EVM\" },\n  { name: \"Rabby\", kind: \"EVM\" },\n  { name: \"Rainbow\", kind: \"EVM\" },\n  { name: \"Phantom\", kind: \"EVM/Solana\" },\n  { name: \"Brave Wallet\", kind: \"EVM\" },\n  { name: \"Bitget Wallet\", kind: \"EVM\" },\n  { name: \"MathWallet\", kind: \"EVM\" },\n  { name: \"Solflare\", kind: \"Solana\" },\n  { name: \"Backpack\", kind: \"Solana\" },\n];\n\nexport const DEFAULT_SETTINGS: Settings = {\n  riskWarnings: true,\n  showConnectOverlay: true,\n  blockHighRisk: true,\n  requireTypedOverride: true,\n  allowOverrideOnPhishing: false,\n  debugMode: false,\n  domainChecks: true,\n  mode: \"BALANCED\",\n  strictBlockApprovalsUnlimited: true,\n  strictBlockSetApprovalForAll: true,\n  strictBlockPermitLike: true,\n  assetEnrichmentEnabled: true,\n  addressIntelEnabled: true,\n  cloudIntelOptIn: true,\n  showUsd: true,\n  planTier: \"FREE\",\n  licenseKey: \"\",\n  trustedDomains: [\n    \"opensea.io\",\n    \"blur.io\",\n    \"app.uniswap.org\",\n    \"uniswap.org\",\n    \"looksrare.org\",\n    \"x2y2.io\",\n    \"etherscan.io\",\n    \"arbitrum.io\",\n    \"polygon.technology\",\n  ],\n  supportedWalletsInfo: SUPPORTED_WALLETS,\n  allowlist: [\n    \"opensea.io\",\n    \"blur.io\",\n    \"app.uniswap.org\",\n    \"uniswap.org\",\n    \"looksrare.org\",\n    \"x2y2.io\",\n    \"etherscan.io\",\n    \"arbitrum.io\",\n    \"polygon.technology\",\n  ],\n  customBlockedDomains: [],\n  customTrustedDomains: [],\n  enableIntel: true,\n  vault: {\n    enabled: false,\n    lockedContracts: [],\n  },\n  simulation: {\n    enabled: false,\n    tenderlyAccount: \"\",\n    tenderlyProject: \"\",\n    tenderlyKey: \"\",\n  },\n  whitelistedDomains: [],\n  fortressMode: false,\n};\n\n", "/**\r\n * Centralized runtime/storage wrappers to avoid \"Cannot read properties of undefined\"\r\n * and \"Extension context invalidated\" errors. Use in content and options scripts only.\r\n * Uses Port (long-lived) to reduce runtime.lastError / SW sleeping issues.\r\n */\r\n\r\nlet _port: chrome.runtime.Port | null = null;\r\n\r\n/** Safe check: avoid crash when context invalidated. Use globalThis.chrome when available. */\r\nexport function canUseRuntime(): boolean {\r\n  try {\r\n    const c = (typeof globalThis !== \"undefined\" ? (globalThis as any).chrome : undefined) ?? (typeof chrome !== \"undefined\" ? chrome : undefined);\r\n    return !!(c?.runtime?.id && typeof c.runtime.sendMessage === \"function\");\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\nexport function isRuntimeUsable(): boolean {\r\n  try {\r\n    return canUseRuntime();\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\nconst CONTEXT_INVALID_TERMS = [\r\n  \"extension context invalidated\",\r\n  \"context invalidated\",\r\n  \"message port closed\",\r\n  \"receiving end does not exist\",\r\n  \"runtime.lastError\",\r\n];\r\n\r\nfunction isContextInvalidError(e: unknown): boolean {\r\n  const msg = String((e as Error)?.message ?? e ?? \"\").toLowerCase();\r\n  return CONTEXT_INVALID_TERMS.some((t) => msg.includes(t));\r\n}\r\n\r\nfunction getPort(): chrome.runtime.Port | null {\r\n  try {\r\n    const c = (typeof globalThis !== \"undefined\" ? (globalThis as any).chrome : undefined) ?? (typeof chrome !== \"undefined\" ? chrome : undefined);\r\n    if (!canUseRuntime() || !c?.runtime?.connect) return null;\r\n    if (_port) return _port;\r\n    _port = c.runtime.connect({ name: \"sg_port\" });\r\n    _port?.onDisconnect.addListener(() => {\r\n      _port = null;\r\n      _portListenerInit = false;\r\n    });\r\n    return _port;\r\n  } catch {\r\n    _port = null;\r\n    return null;\r\n  }\r\n}\r\n\r\nconst _portPending = new Map<string, (r: any) => void>();\r\nlet _portListenerInit = false;\r\n\r\nfunction initPortListener() {\r\n  const p = getPort();\r\n  if (!p || _portListenerInit) return;\r\n  _portListenerInit = true;\r\n  p.onMessage.addListener((resp: any) => {\r\n    const cb = resp?.requestId != null ? _portPending.get(String(resp.requestId)) : undefined;\r\n    if (cb) {\r\n      _portPending.delete(String(resp.requestId));\r\n      try { cb(resp); } catch {}\r\n    }\r\n  });\r\n}\r\n\r\n/** Port-based request (preferred over sendMessage to avoid runtime.lastError). Sends PING via sendMessage first if port not yet connected (wakes SW). */\r\nexport function portRequest<T = any>(msg: unknown, timeoutMs = 2500): Promise<T | null> {\r\n  return new Promise((resolve) => {\r\n    (async () => {\r\n      try {\r\n        if (!_port) {\r\n          try {\r\n            await new Promise<void>((r) => {\r\n              const c = (typeof globalThis !== \"undefined\" ? (globalThis as any).chrome : undefined) ?? (typeof chrome !== \"undefined\" ? chrome : undefined);\r\n              if (!c?.runtime?.sendMessage) return r();\r\n              c.runtime.sendMessage({ type: \"PING\" }, () => {\r\n                r();\r\n              });\r\n              setTimeout(() => r(), 600);\r\n            });\r\n          } catch {\r\n            // ignore\r\n          }\r\n        }\r\n        const p = getPort();\r\n        if (!p) {\r\n          resolve(null);\r\n          return;\r\n        }\r\n        initPortListener();\r\n        const requestId = typeof crypto?.randomUUID === \"function\" ? crypto.randomUUID() : `sg_${Date.now()}_${Math.random().toString(36).slice(2)}`;\r\n        const payload = { ...(msg as object), requestId };\r\n\r\n        const timer = setTimeout(() => {\r\n          if (_portPending.has(requestId)) {\r\n            _portPending.delete(requestId);\r\n            resolve(null);\r\n          }\r\n        }, timeoutMs);\r\n\r\n        _portPending.set(requestId, (resp: any) => {\r\n          clearTimeout(timer);\r\n          resolve(resp != null ? (resp as T) : null);\r\n        });\r\n\r\n        try {\r\n          p.postMessage(payload);\r\n        } catch (e) {\r\n          clearTimeout(timer);\r\n          _portPending.delete(requestId);\r\n          resolve(null);\r\n        }\r\n      } catch {\r\n        resolve(null);\r\n      }\r\n    })();\r\n  });\r\n}\r\n\r\nconst DEFAULT_SEND_MS = 4000;\r\nconst RETRY_SEND_MS = 2500;\r\nconst LOG_PREFIX = \"[SignGuard]\";\r\n\r\nexport type SafeSendMessageOptions = {\r\n  timeoutMs?: number;\r\n  preferPort?: boolean;\r\n};\r\n\r\nfunction sendMessageOneAttempt<T>(msg: unknown, timeoutMs: number): Promise<T | null> {\r\n  return new Promise((resolve) => {\r\n    let settled = false;\r\n    const once = (value: T | null) => {\r\n      if (settled) return;\r\n      settled = true;\r\n      resolve(value);\r\n    };\r\n\r\n    const c = (typeof globalThis !== \"undefined\" ? (globalThis as any).chrome : undefined) ?? (typeof chrome !== \"undefined\" ? chrome : undefined);\r\n    const rt = (() => {\r\n      try {\r\n        return c?.runtime ?? null;\r\n      } catch {\r\n        return null;\r\n      }\r\n    })();\r\n    if (!rt || !rt.id || typeof rt.sendMessage !== \"function\") {\r\n      once(null);\r\n      return;\r\n    }\r\n\r\n    const timer = setTimeout(() => {\r\n      once(null);\r\n    }, timeoutMs);\r\n\r\n    try {\r\n      rt.sendMessage(msg, (resp: T) => {\r\n        if (settled) return;\r\n        clearTimeout(timer);\r\n        try {\r\n          const err = (c?.runtime as any)?.lastError;\r\n          if (err) {\r\n            once(null);\r\n            return;\r\n          }\r\n          once(resp ?? null);\r\n        } catch {\r\n          once(null);\r\n        }\r\n      });\r\n    } catch (e) {\r\n      clearTimeout(timer);\r\n      // Production: no console.warn; keep only console.error in critical catch blocks\r\n      once(null);\r\n    }\r\n  });\r\n}\r\n\r\nexport function safeSendMessage<T = any>(msg: unknown, options?: number | SafeSendMessageOptions): Promise<T | null> {\r\n  const timeoutMs = typeof options === \"number\" ? options : (options?.timeoutMs ?? DEFAULT_SEND_MS);\r\n  const preferPort = typeof options === \"object\" && options?.preferPort === true;\r\n\r\n  if (preferPort) {\r\n    return portRequest<T>(msg, timeoutMs).then((r) => {\r\n      if (r != null && (r as any)?.ok !== false) return r as T;\r\n      return sendMessageOneAttempt<T>(msg, timeoutMs).then((res) => {\r\n        if (res != null) return res;\r\n        return sendMessageOneAttempt<T>(msg, RETRY_SEND_MS);\r\n      });\r\n    });\r\n  }\r\n\r\n  return sendMessageOneAttempt<T>(msg, timeoutMs).then((r) => {\r\n    if (r != null) return r;\r\n    return sendMessageOneAttempt<T>(msg, RETRY_SEND_MS);\r\n  });\r\n}\r\n\r\nexport type StorageResult<T> = { ok: true; data: T } | { ok: false; error: string };\r\n\r\nexport async function safeStorageGet<T = any>(keys: unknown): Promise<StorageResult<T>> {\r\n  return new Promise((resolve) => {\r\n    try {\r\n      if (!isRuntimeUsable() || !chrome?.storage?.sync) {\r\n        resolve({ ok: false, error: \"storage_unavailable\" });\r\n        return;\r\n      }\r\n      chrome.storage.sync.get(keys as any, (items: T) => {\r\n        try {\r\n          const err = chrome.runtime.lastError;\r\n          if (err) {\r\n            resolve({ ok: false, error: err.message || String(err) });\r\n            return;\r\n          }\r\n          resolve({ ok: true, data: items });\r\n        } catch (e) {\r\n          resolve({ ok: false, error: (e as Error)?.message || String(e) });\r\n        }\r\n      });\r\n    } catch (e) {\r\n      resolve({ ok: false, error: (e as Error)?.message || String(e) });\r\n    }\r\n  });\r\n}\r\n\r\nexport async function safeStorageSet(obj: Record<string, unknown>): Promise<StorageResult<true>> {\r\n  return new Promise((resolve) => {\r\n    try {\r\n      if (!isRuntimeUsable() || !chrome?.storage?.sync) {\r\n        resolve({ ok: false, error: \"storage_unavailable\" });\r\n        return;\r\n      }\r\n      chrome.storage.sync.set(obj, () => {\r\n        try {\r\n          const err = chrome.runtime.lastError;\r\n          if (err) {\r\n            resolve({ ok: false, error: err.message || String(err) });\r\n            return;\r\n          }\r\n          resolve({ ok: true, data: true });\r\n        } catch (e) {\r\n          resolve({ ok: false, error: (e as Error)?.message || String(e) });\r\n        }\r\n      });\r\n    } catch (e) {\r\n      resolve({ ok: false, error: (e as Error)?.message || String(e) });\r\n    }\r\n  });\r\n}\r\n\r\nexport async function safeLocalGet<T = any>(key: string): Promise<T | null> {\r\n  return new Promise((resolve) => {\r\n    try {\r\n      if (!isRuntimeUsable() || !chrome?.storage?.local) {\r\n        resolve(null);\r\n        return;\r\n      }\r\n      chrome.storage.local.get(key, (r: Record<string, T>) => {\r\n        try {\r\n          const err = chrome.runtime.lastError;\r\n          if (err) {\r\n            resolve(null);\r\n            return;\r\n          }\r\n          resolve(((r as any)?.[key] as T) ?? null);\r\n        } catch {\r\n          resolve(null);\r\n        }\r\n      });\r\n    } catch {\r\n      resolve(null);\r\n    }\r\n  });\r\n}\r\n\r\nexport async function safeLocalSet(obj: Record<string, unknown>): Promise<boolean> {\r\n  return new Promise((resolve) => {\r\n    try {\r\n      if (!isRuntimeUsable() || !chrome?.storage?.local) {\r\n        resolve(false);\r\n        return;\r\n      }\r\n      chrome.storage.local.set(obj, () => {\r\n        try {\r\n          const err = chrome.runtime.lastError;\r\n          resolve(!err);\r\n        } catch {\r\n          resolve(false);\r\n        }\r\n      });\r\n    } catch {\r\n      resolve(false);\r\n    }\r\n  });\r\n}\r\n\r\n/** Safe getURL - returns empty string if runtime unusable */\r\nexport function safeGetURL(path: string): string {\r\n  try {\r\n    if (!isRuntimeUsable() || !chrome.runtime.getURL) return \"\";\r\n    return chrome.runtime.getURL(path);\r\n  } catch {\r\n    return \"\";\r\n  }\r\n}\r\n", "import type { Settings } from \"../shared/types\";\r\nimport { DEFAULT_SETTINGS } from \"../shared/types\";\r\nimport { safeStorageGet } from \"../runtimeSafe\";\r\n\r\nconst LAST_VERIFICATION_KEY = \"sg_lastVerification\";\r\nconst INTEL_KEY = \"sg_intel\";\r\n\r\nexport interface Allowance {\r\n  tokenSymbol: string;\r\n  tokenAddress: string;\r\n  amount: string;\r\n  amountRaw?: string;\r\n  spenderAddress: string;\r\n  spenderLabel?: string;\r\n}\r\n\r\nconst $ = <T extends HTMLElement>(id: string) => document.getElementById(id) as T;\r\n\r\nasync function getStorageSync(): Promise<Partial<Settings>> {\r\n  const r = await safeStorageGet<Record<string, unknown>>(DEFAULT_SETTINGS as unknown as Record<string, unknown>);\r\n  return r.ok ? (r.data as Partial<Settings>) : {};\r\n}\r\n\r\nfunction getStorageLocal(keys: string[]): Promise<Record<string, unknown>> {\r\n  return new Promise((resolve) => {\r\n    try {\r\n      if (!chrome?.storage?.local) return resolve({});\r\n      const keyObj = keys.length ? keys.reduce<Record<string, unknown>>((o, k) => ({ ...o, [k]: null }), {}) : {};\r\n      chrome.storage.local.get(keyObj, (r: Record<string, unknown>) => {\r\n        if (chrome.runtime?.lastError) return resolve({});\r\n        resolve(r || {});\r\n      });\r\n    } catch {\r\n      resolve({});\r\n    }\r\n  });\r\n}\r\n\r\nfunction setLastVerification(ts: number) {\r\n  try {\r\n    chrome?.storage?.local?.set?.({ [LAST_VERIFICATION_KEY]: ts }, () => void 0);\r\n  } catch {}\r\n}\r\n\r\nfunction formatDate(ts: number | null | undefined): string {\r\n  if (!ts || !Number.isFinite(ts)) return \"\u2014\";\r\n  try {\r\n    return new Date(ts).toLocaleString();\r\n  } catch {\r\n    return String(ts);\r\n  }\r\n}\r\n\r\nconst HISTORY_KEY = \"sg_history_v1\";\r\n\r\n/** Health check: last verification date and protection level from storage. */\r\nasync function renderHealthCheck() {\r\n  const settings = await getStorageSync();\r\n  const local = await getStorageLocal([LAST_VERIFICATION_KEY, INTEL_KEY, HISTORY_KEY]);\r\n\r\n  const lastVerificationTs =\r\n    (local[LAST_VERIFICATION_KEY] as number) ??\r\n    (typeof (local[INTEL_KEY] as any)?.updatedAt === \"number\" ? (local[INTEL_KEY] as any).updatedAt : null);\r\n  const lastEl = $(\"lastVerification\");\r\n  if (lastEl) lastEl.textContent = formatDate(lastVerificationTs);\r\n\r\n  const mode = settings.mode ?? DEFAULT_SETTINGS.mode ?? \"BALANCED\";\r\n  const isPaused = mode === \"OFF\";\r\n  const levelEl = $(\"protectionLevel\");\r\n  if (levelEl) {\r\n    levelEl.textContent = isPaused ? \"Pausado\" : \"Ativo\";\r\n    levelEl.className = isPaused ? \"sg-badge-paused\" : \"sg-badge-active\";\r\n  }\r\n\r\n  const history = local[HISTORY_KEY] as unknown[] | undefined;\r\n  const historyArr = Array.isArray(history) ? history : [];\r\n  const risksBlocked = historyArr.filter((e: any) => e?.verdict === \"deny\" || e?.verdict === \"block\").length;\r\n  const risksEl = $(\"statRisksBlocked\");\r\n  if (risksEl) risksEl.textContent = String(risksBlocked);\r\n\r\n  const valueSavedEl = $(\"statValueSaved\");\r\n  if (valueSavedEl) valueSavedEl.textContent = \"\u2014\";\r\n}\r\n\r\n/** Mock data for Token Allowances (no Covalent/Etherscan key yet). */\r\nexport function fetchAllowances(_address: string): Promise<Allowance[]> {\r\n  return new Promise((resolve) => {\r\n    setTimeout(() => {\r\n      resolve([\r\n        {\r\n          tokenSymbol: \"USDC\",\r\n          tokenAddress: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\r\n          amount: \"Unlimited\",\r\n          amountRaw: \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\",\r\n          spenderAddress: \"0x1234567890123456789012345678901234567890\",\r\n          spenderLabel: \"0x123...890\",\r\n        },\r\n        {\r\n          tokenSymbol: \"WETH\",\r\n          tokenAddress: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\",\r\n          amount: \"500.0\",\r\n          amountRaw: \"500000000000000000000\",\r\n          spenderAddress: \"0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\",\r\n          spenderLabel: \"Uniswap Router\",\r\n        },\r\n      ]);\r\n    }, 300);\r\n  });\r\n}\r\n\r\n/** Open Revoke.cash for the given address (extension pages have no window.ethereum). */\r\nfunction openRevokeCash(walletAddress: string) {\r\n  const base = \"https://revoke.cash/address/\";\r\n  const url = walletAddress ? base + encodeURIComponent(walletAddress) : \"https://revoke.cash/\";\r\n  try {\r\n    chrome.tabs.create({ url });\r\n  } catch {\r\n    window.open(url, \"_blank\");\r\n  }\r\n}\r\n\r\nfunction shortenAddr(addr: string): string {\r\n  if (!addr || addr.length < 12) return addr;\r\n  return `${addr.slice(0, 6)}\u2026${addr.slice(-4)}`;\r\n}\r\n\r\nfunction renderAllowances(list: Allowance[], walletAddressForRevoke: string) {\r\n  const listEl = $(\"allowancesList\");\r\n  const emptyEl = $(\"allowancesEmpty\");\r\n  if (!list.length) {\r\n    listEl.innerHTML = \"\";\r\n    if (emptyEl) emptyEl.classList.remove(\"hidden\");\r\n    return;\r\n  }\r\n  if (emptyEl) emptyEl.classList.add(\"hidden\");\r\n  listEl.innerHTML = `\r\n    <table class=\"sg-allowances-table\" role=\"grid\">\r\n      <thead>\r\n        <tr>\r\n          <th>Token</th>\r\n          <th>Montante</th>\r\n          <th>Spender</th>\r\n          <th></th>\r\n        </tr>\r\n      </thead>\r\n      <tbody>\r\n        ${list\r\n          .map(\r\n            (a) => `\r\n        <tr>\r\n          <td><span class=\"sg-mono\">${escapeHtml(a.tokenSymbol)}</span></td>\r\n          <td>${escapeHtml(a.amount)}</td>\r\n          <td class=\"sg-mono\">${escapeHtml(a.spenderLabel ?? shortenAddr(a.spenderAddress))}</td>\r\n          <td><button type=\"button\" class=\"sg-btn-revoke revoke-btn\">Revoke.cash</button></td>\r\n        </tr>`\r\n          )\r\n          .join(\"\")}\r\n      </tbody>\r\n    </table>`;\r\n\r\n  listEl.querySelectorAll(\".revoke-btn\").forEach((btn) => {\r\n    btn.addEventListener(\"click\", () => openRevokeCash(walletAddressForRevoke));\r\n  });\r\n}\r\n\r\nfunction escapeHtml(s: string): string {\r\n  const div = document.createElement(\"div\");\r\n  div.textContent = s;\r\n  return div.innerHTML;\r\n}\r\n\r\nlet cachedAllowances: Allowance[] = [];\r\n\r\nasync function loadAllowances() {\r\n  const input = $<HTMLInputElement>(\"walletAddress\");\r\n  const address = (input?.value ?? \"\").trim();\r\n  const errEl = $(\"allowancesError\");\r\n  errEl.classList.add(\"hidden\");\r\n  errEl.textContent = \"\";\r\n  if (!address) {\r\n    cachedAllowances = [];\r\n    renderAllowances([], \"\");\r\n    return;\r\n  }\r\n  try {\r\n    const list = await fetchAllowances(address);\r\n    cachedAllowances = list;\r\n    renderAllowances(list, address);\r\n  } catch (e: any) {\r\n    errEl.textContent = e?.message ?? \"Erro ao carregar aprova\u00E7\u00F5es.\";\r\n    errEl.classList.remove(\"hidden\");\r\n    cachedAllowances = [];\r\n    renderAllowances([], \"\");\r\n  }\r\n}\r\n\r\nfunction init() {\r\n  const configLink = $(\"configLink\");\r\n  if (configLink && typeof chrome?.runtime?.getURL === \"function\") {\r\n    (configLink as HTMLAnchorElement).href = chrome.runtime.getURL(\"options.html\");\r\n  }\r\n\r\n  renderHealthCheck();\r\n  setLastVerification(Date.now());\r\n\r\n  $(\"loadAllowances\")?.addEventListener(\"click\", loadAllowances);\r\n  $(\"refreshAllowances\")?.addEventListener(\"click\", () => {\r\n    if (cachedAllowances.length) loadAllowances();\r\n  });\r\n}\r\n\r\ninit();\r\n"],
  "mappings": ";AA0ZO,IAAM,oBAA4C;AAAA,EACvD,EAAE,MAAM,YAAY,MAAM,MAAM;AAAA,EAChC,EAAE,MAAM,mBAAmB,MAAM,MAAM;AAAA,EACvC,EAAE,MAAM,gBAAgB,MAAM,MAAM;AAAA,EACpC,EAAE,MAAM,cAAc,MAAM,MAAM;AAAA,EAClC,EAAE,MAAM,gBAAgB,MAAM,MAAM;AAAA,EACpC,EAAE,MAAM,SAAS,MAAM,MAAM;AAAA,EAC7B,EAAE,MAAM,WAAW,MAAM,MAAM;AAAA,EAC/B,EAAE,MAAM,WAAW,MAAM,aAAa;AAAA,EACtC,EAAE,MAAM,gBAAgB,MAAM,MAAM;AAAA,EACpC,EAAE,MAAM,iBAAiB,MAAM,MAAM;AAAA,EACrC,EAAE,MAAM,cAAc,MAAM,MAAM;AAAA,EAClC,EAAE,MAAM,YAAY,MAAM,SAAS;AAAA,EACnC,EAAE,MAAM,YAAY,MAAM,SAAS;AACrC;AAEO,IAAM,mBAA6B;AAAA,EACxC,cAAc;AAAA,EACd,oBAAoB;AAAA,EACpB,eAAe;AAAA,EACf,sBAAsB;AAAA,EACtB,yBAAyB;AAAA,EACzB,WAAW;AAAA,EACX,cAAc;AAAA,EACd,MAAM;AAAA,EACN,+BAA+B;AAAA,EAC/B,8BAA8B;AAAA,EAC9B,uBAAuB;AAAA,EACvB,wBAAwB;AAAA,EACxB,qBAAqB;AAAA,EACrB,iBAAiB;AAAA,EACjB,SAAS;AAAA,EACT,UAAU;AAAA,EACV,YAAY;AAAA,EACZ,gBAAgB;AAAA,IACd;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAAA,EACA,sBAAsB;AAAA,EACtB,WAAW;AAAA,IACT;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAAA,EACA,sBAAsB,CAAC;AAAA,EACvB,sBAAsB,CAAC;AAAA,EACvB,aAAa;AAAA,EACb,OAAO;AAAA,IACL,SAAS;AAAA,IACT,iBAAiB,CAAC;AAAA,EACpB;AAAA,EACA,YAAY;AAAA,IACV,SAAS;AAAA,IACT,iBAAiB;AAAA,IACjB,iBAAiB;AAAA,IACjB,aAAa;AAAA,EACf;AAAA,EACA,oBAAoB,CAAC;AAAA,EACrB,cAAc;AAChB;;;ACzdO,SAAS,gBAAyB;AACvC,MAAI;AACF,UAAM,KAAK,OAAO,eAAe,cAAe,WAAmB,SAAS,YAAe,OAAO,WAAW,cAAc,SAAS;AACpI,WAAO,CAAC,EAAE,GAAG,SAAS,MAAM,OAAO,EAAE,QAAQ,gBAAgB;AAAA,EAC/D,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAEO,SAAS,kBAA2B;AACzC,MAAI;AACF,WAAO,cAAc;AAAA,EACvB,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAsLA,eAAsB,eAAwB,MAA0C;AACtF,SAAO,IAAI,QAAQ,CAAC,YAAY;AAC9B,QAAI;AACF,UAAI,CAAC,gBAAgB,KAAK,CAAC,QAAQ,SAAS,MAAM;AAChD,gBAAQ,EAAE,IAAI,OAAO,OAAO,sBAAsB,CAAC;AACnD;AAAA,MACF;AACA,aAAO,QAAQ,KAAK,IAAI,MAAa,CAAC,UAAa;AACjD,YAAI;AACF,gBAAM,MAAM,OAAO,QAAQ;AAC3B,cAAI,KAAK;AACP,oBAAQ,EAAE,IAAI,OAAO,OAAO,IAAI,WAAW,OAAO,GAAG,EAAE,CAAC;AACxD;AAAA,UACF;AACA,kBAAQ,EAAE,IAAI,MAAM,MAAM,MAAM,CAAC;AAAA,QACnC,SAAS,GAAG;AACV,kBAAQ,EAAE,IAAI,OAAO,OAAQ,GAAa,WAAW,OAAO,CAAC,EAAE,CAAC;AAAA,QAClE;AAAA,MACF,CAAC;AAAA,IACH,SAAS,GAAG;AACV,cAAQ,EAAE,IAAI,OAAO,OAAQ,GAAa,WAAW,OAAO,CAAC,EAAE,CAAC;AAAA,IAClE;AAAA,EACF,CAAC;AACH;;;ACjOA,IAAM,wBAAwB;AAC9B,IAAM,YAAY;AAWlB,IAAM,IAAI,CAAwB,OAAe,SAAS,eAAe,EAAE;AAE3E,eAAe,iBAA6C;AAC1D,QAAM,IAAI,MAAM,eAAwC,gBAAsD;AAC9G,SAAO,EAAE,KAAM,EAAE,OAA6B,CAAC;AACjD;AAEA,SAAS,gBAAgB,MAAkD;AACzE,SAAO,IAAI,QAAQ,CAAC,YAAY;AAC9B,QAAI;AACF,UAAI,CAAC,QAAQ,SAAS,MAAO,QAAO,QAAQ,CAAC,CAAC;AAC9C,YAAM,SAAS,KAAK,SAAS,KAAK,OAAgC,CAAC,GAAG,OAAO,EAAE,GAAG,GAAG,CAAC,CAAC,GAAG,KAAK,IAAI,CAAC,CAAC,IAAI,CAAC;AAC1G,aAAO,QAAQ,MAAM,IAAI,QAAQ,CAAC,MAA+B;AAC/D,YAAI,OAAO,SAAS,UAAW,QAAO,QAAQ,CAAC,CAAC;AAChD,gBAAQ,KAAK,CAAC,CAAC;AAAA,MACjB,CAAC;AAAA,IACH,QAAQ;AACN,cAAQ,CAAC,CAAC;AAAA,IACZ;AAAA,EACF,CAAC;AACH;AAEA,SAAS,oBAAoB,IAAY;AACvC,MAAI;AACF,YAAQ,SAAS,OAAO,MAAM,EAAE,CAAC,qBAAqB,GAAG,GAAG,GAAG,MAAM,MAAM;AAAA,EAC7E,QAAQ;AAAA,EAAC;AACX;AAEA,SAAS,WAAW,IAAuC;AACzD,MAAI,CAAC,MAAM,CAAC,OAAO,SAAS,EAAE,EAAG,QAAO;AACxC,MAAI;AACF,WAAO,IAAI,KAAK,EAAE,EAAE,eAAe;AAAA,EACrC,QAAQ;AACN,WAAO,OAAO,EAAE;AAAA,EAClB;AACF;AAEA,IAAM,cAAc;AAGpB,eAAe,oBAAoB;AACjC,QAAM,WAAW,MAAM,eAAe;AACtC,QAAM,QAAQ,MAAM,gBAAgB,CAAC,uBAAuB,WAAW,WAAW,CAAC;AAEnF,QAAM,qBACH,MAAM,qBAAqB,MAC3B,OAAQ,MAAM,SAAS,GAAW,cAAc,WAAY,MAAM,SAAS,EAAU,YAAY;AACpG,QAAM,SAAS,EAAE,kBAAkB;AACnC,MAAI,OAAQ,QAAO,cAAc,WAAW,kBAAkB;AAE9D,QAAM,OAAO,SAAS,QAAQ,iBAAiB,QAAQ;AACvD,QAAM,WAAW,SAAS;AAC1B,QAAM,UAAU,EAAE,iBAAiB;AACnC,MAAI,SAAS;AACX,YAAQ,cAAc,WAAW,YAAY;AAC7C,YAAQ,YAAY,WAAW,oBAAoB;AAAA,EACrD;AAEA,QAAM,UAAU,MAAM,WAAW;AACjC,QAAM,aAAa,MAAM,QAAQ,OAAO,IAAI,UAAU,CAAC;AACvD,QAAM,eAAe,WAAW,OAAO,CAAC,MAAW,GAAG,YAAY,UAAU,GAAG,YAAY,OAAO,EAAE;AACpG,QAAM,UAAU,EAAE,kBAAkB;AACpC,MAAI,QAAS,SAAQ,cAAc,OAAO,YAAY;AAEtD,QAAM,eAAe,EAAE,gBAAgB;AACvC,MAAI,aAAc,cAAa,cAAc;AAC/C;AAGO,SAAS,gBAAgB,UAAwC;AACtE,SAAO,IAAI,QAAQ,CAAC,YAAY;AAC9B,eAAW,MAAM;AACf,cAAQ;AAAA,QACN;AAAA,UACE,aAAa;AAAA,UACb,cAAc;AAAA,UACd,QAAQ;AAAA,UACR,WAAW;AAAA,UACX,gBAAgB;AAAA,UAChB,cAAc;AAAA,QAChB;AAAA,QACA;AAAA,UACE,aAAa;AAAA,UACb,cAAc;AAAA,UACd,QAAQ;AAAA,UACR,WAAW;AAAA,UACX,gBAAgB;AAAA,UAChB,cAAc;AAAA,QAChB;AAAA,MACF,CAAC;AAAA,IACH,GAAG,GAAG;AAAA,EACR,CAAC;AACH;AAGA,SAAS,eAAe,eAAuB;AAC7C,QAAM,OAAO;AACb,QAAM,MAAM,gBAAgB,OAAO,mBAAmB,aAAa,IAAI;AACvE,MAAI;AACF,WAAO,KAAK,OAAO,EAAE,IAAI,CAAC;AAAA,EAC5B,QAAQ;AACN,WAAO,KAAK,KAAK,QAAQ;AAAA,EAC3B;AACF;AAEA,SAAS,YAAY,MAAsB;AACzC,MAAI,CAAC,QAAQ,KAAK,SAAS,GAAI,QAAO;AACtC,SAAO,GAAG,KAAK,MAAM,GAAG,CAAC,CAAC,SAAI,KAAK,MAAM,EAAE,CAAC;AAC9C;AAEA,SAAS,iBAAiB,MAAmB,wBAAgC;AAC3E,QAAM,SAAS,EAAE,gBAAgB;AACjC,QAAM,UAAU,EAAE,iBAAiB;AACnC,MAAI,CAAC,KAAK,QAAQ;AAChB,WAAO,YAAY;AACnB,QAAI,QAAS,SAAQ,UAAU,OAAO,QAAQ;AAC9C;AAAA,EACF;AACA,MAAI,QAAS,SAAQ,UAAU,IAAI,QAAQ;AAC3C,SAAO,YAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAWX,KACC;AAAA,IACC,CAAC,MAAM;AAAA;AAAA,sCAEmB,WAAW,EAAE,WAAW,CAAC;AAAA,gBAC/C,WAAW,EAAE,MAAM,CAAC;AAAA,gCACJ,WAAW,EAAE,gBAAgB,YAAY,EAAE,cAAc,CAAC,CAAC;AAAA;AAAA;AAAA,EAGjF,EACC,KAAK,EAAE,CAAC;AAAA;AAAA;AAIjB,SAAO,iBAAiB,aAAa,EAAE,QAAQ,CAAC,QAAQ;AACtD,QAAI,iBAAiB,SAAS,MAAM,eAAe,sBAAsB,CAAC;AAAA,EAC5E,CAAC;AACH;AAEA,SAAS,WAAW,GAAmB;AACrC,QAAM,MAAM,SAAS,cAAc,KAAK;AACxC,MAAI,cAAc;AAClB,SAAO,IAAI;AACb;AAEA,IAAI,mBAAgC,CAAC;AAErC,eAAe,iBAAiB;AAC9B,QAAM,QAAQ,EAAoB,eAAe;AACjD,QAAM,WAAW,OAAO,SAAS,IAAI,KAAK;AAC1C,QAAM,QAAQ,EAAE,iBAAiB;AACjC,QAAM,UAAU,IAAI,QAAQ;AAC5B,QAAM,cAAc;AACpB,MAAI,CAAC,SAAS;AACZ,uBAAmB,CAAC;AACpB,qBAAiB,CAAC,GAAG,EAAE;AACvB;AAAA,EACF;AACA,MAAI;AACF,UAAM,OAAO,MAAM,gBAAgB,OAAO;AAC1C,uBAAmB;AACnB,qBAAiB,MAAM,OAAO;AAAA,EAChC,SAAS,GAAQ;AACf,UAAM,cAAc,GAAG,WAAW;AAClC,UAAM,UAAU,OAAO,QAAQ;AAC/B,uBAAmB,CAAC;AACpB,qBAAiB,CAAC,GAAG,EAAE;AAAA,EACzB;AACF;AAEA,SAAS,OAAO;AACd,QAAM,aAAa,EAAE,YAAY;AACjC,MAAI,cAAc,OAAO,QAAQ,SAAS,WAAW,YAAY;AAC/D,IAAC,WAAiC,OAAO,OAAO,QAAQ,OAAO,cAAc;AAAA,EAC/E;AAEA,oBAAkB;AAClB,sBAAoB,KAAK,IAAI,CAAC;AAE9B,IAAE,gBAAgB,GAAG,iBAAiB,SAAS,cAAc;AAC7D,IAAE,mBAAmB,GAAG,iBAAiB,SAAS,MAAM;AACtD,QAAI,iBAAiB,OAAQ,gBAAe;AAAA,EAC9C,CAAC;AACH;AAEA,KAAK;",
  "names": []
}
